<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/akash/fiverrsupport/FiverrLauncherService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/akash/fiverrsupport/FiverrLauncherService.kt" />
              <option name="originalContent" value="package com.akash.fiverrsupport&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.AlarmManager&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.BroadcastReceiver&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.content.pm.PackageManager&#10;import android.graphics.Canvas&#10;import android.graphics.Color&#10;import android.graphics.Paint&#10;import android.graphics.PixelFormat&#10;import android.graphics.RectF&#10;import android.media.AudioManager&#10;import android.os.Build&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.os.PowerManager&#10;import android.os.VibrationEffect&#10;import android.os.VibrationAttributes&#10;import android.os.Vibrator&#10;import android.provider.Settings&#10;import android.telecom.TelecomManager&#10;import android.telephony.PhoneStateListener&#10;import android.telephony.TelephonyCallback&#10;import android.telephony.TelephonyManager&#10;import android.util.Log&#10;import android.view.Gravity&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.WindowManager&#10;import android.widget.Toast&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import com.akash.fiverrsupport.utils.isAppInForeground&#10;&#10;class FiverrLauncherService : Service() {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var isRunning = false&#10;    private var isPaused = false // New: Track if service is paused due to user interaction&#10;    private var launchInterval = 20000L // Default 20 seconds&#10;    private var lastUserInteractionTime = 0L&#10;    private val idleTimeout = 5000L&#10;&#10;    // Flag to ignore touch events during automated gestures&#10;    private var isPerformingAutomatedGesture = false&#10;&#10;    // Screen wake-lock components&#10;    private var windowManager: WindowManager? = null&#10;    private var overlayView: CircularTimerView? = null&#10;    private var touchDetectorView: TouchDetectorView? = null&#10;    private var wakeLock: PowerManager.WakeLock? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var isScreenOn = true&#10;    private var isVibrationServiceRunning = false // Track if we intentionally started vibration&#10;    private var originalBrightness: Int = -1 // Store original brightness to restore later&#10;&#10;    private var nextLaunchTime = 0L&#10;&#10;    // Media playback detection&#10;    private var audioManager: AudioManager? = null&#10;&#10;    // Call detection&#10;    private var telephonyManager: TelephonyManager? = null&#10;    private var telecomManager: TelecomManager? = null&#10;    private var callStateListener: Any? = null // Can be PhoneStateListener or TelephonyCallback&#10;    private var isInCall = false&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        createNotificationChannel()&#10;&#10;        // Initialize vibrator (modern API)&#10;        vibrator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            getSystemService(Vibrator::class.java)&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            getSystemService(VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        // Initialize AudioManager for media playback detection&#10;        audioManager = getSystemService(AUDIO_SERVICE) as AudioManager&#10;&#10;        // Initialize TelephonyManager and TelecomManager for call detection&#10;        telephonyManager = getSystemService(TELEPHONY_SERVICE) as TelephonyManager&#10;        telecomManager = getSystemService(TELECOM_SERVICE) as TelecomManager&#10;&#10;        // Register call state listener&#10;        registerCallStateListener()&#10;&#10;        // Register screen state receiver&#10;        val filter = IntentFilter().apply {&#10;            addAction(Intent.ACTION_SCREEN_ON)&#10;            addAction(Intent.ACTION_SCREEN_OFF)&#10;            addAction(Intent.ACTION_USER_PRESENT) // Fires when user unlocks device&#10;        }&#10;        registerReceiver(screenStateReceiver, filter)&#10;&#10;        // Check current screen state&#10;        val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;        isScreenOn = powerManager.isInteractive&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;Service created, screen is ${if (isScreenOn) &quot;ON&quot; else &quot;OFF&quot;}&quot;)&#10;    }&#10;&#10;    // Screen state receiver to detect screen on/off&#10;    private val screenStateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                Intent.ACTION_SCREEN_OFF -&gt; {&#10;                    isScreenOn = false&#10;                    Log.d(&quot;nvm&quot;, &quot;Screen turned OFF - pausing service and starting vibration&quot;)&#10;&#10;                    // Pause the service (like touch does) but without idle checker&#10;                    // We'll resume after unlock instead&#10;                    if (!isPaused &amp;&amp; isRunning) {&#10;                        // Reset lastUserInteractionTime to 0 to mark this as &quot;paused by screen lock&quot;&#10;                        lastUserInteractionTime = 0&#10;                        pauseService(startIdleChecker = false) // Don't start idle checker for screen lock&#10;                        Log.d(&quot;nvm&quot;, &quot;Service paused due to screen lock (lastUserInteractionTime reset to 0)&quot;)&#10;                    }&#10;&#10;                    // Start vibration alert&#10;                    startVibrationAlert()&#10;                }&#10;                Intent.ACTION_USER_PRESENT -&gt; {&#10;                    // USER_PRESENT fires when user unlocks the device (most reliable)&#10;                    isScreenOn = true&#10;                    Log.d(&quot;nvm&quot;, &quot;USER_PRESENT received - user unlocked device&quot;)&#10;&#10;                    // Stop vibration&#10;                    if (isVibrationServiceRunning) {&#10;                        Log.d(&quot;nvm&quot;, &quot;Stopping vibration after unlock&quot;)&#10;                        stopVibrationAlert()&#10;                    }&#10;&#10;                    // Check if user was paused by touch interaction (idle checker is running)&#10;                    // If so, respect the 1-minute idle timeout instead of instant resume&#10;                    if (isPaused &amp;&amp; isRunning &amp;&amp; lastUserInteractionTime &gt; 0) {&#10;                        val idleTime = System.currentTimeMillis() - lastUserInteractionTime&#10;                        val mediaPlaying = isMediaPlaying()&#10;                        val inCall = isInCall()&#10;&#10;                        if (idleTime &gt;= idleTimeout) {&#10;                            if (mediaPlaying) {&#10;                                Log.d(&quot;nvm&quot;, &quot;Idle timeout met but media is playing - NOT resuming&quot;)&#10;                            } else if (inCall) {&#10;                                Log.d(&quot;nvm&quot;, &quot;Idle timeout met but in a call - NOT resuming&quot;)&#10;                            } else {&#10;                                Log.d(&quot;nvm&quot;, &quot;Auto-resuming service after unlock (idle timeout met: ${idleTime}ms)&quot;)&#10;                                resumeService()&#10;                            }&#10;                        } else {&#10;                            Log.d(&quot;nvm&quot;, &quot;Not resuming yet - only ${idleTime}ms idle, need ${idleTimeout}ms (${idleTimeout - idleTime}ms remaining)&quot;)&#10;                            // Don't resume - let idle checker continue&#10;                        }&#10;                    } else if (isPaused &amp;&amp; isRunning &amp;&amp; lastUserInteractionTime == 0L) {&#10;                        // Service was paused by screen lock (not touch), so resume instantly&#10;                        // But still check for media playback and calls&#10;                        val mediaPlaying = isMediaPlaying()&#10;                        val inCall = isInCall()&#10;                        if (mediaPlaying) {&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen unlocked but media is playing - NOT resuming, starting idle checker&quot;)&#10;                            // Start idle checker to wait for media to stop&#10;                            lastUserInteractionTime = System.currentTimeMillis()&#10;                            handler.post(idleCheckerRunnable)&#10;                        } else if (inCall) {&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen unlocked but in a call - NOT resuming, starting idle checker&quot;)&#10;                            // Start idle checker to wait for call to end&#10;                            lastUserInteractionTime = System.currentTimeMillis()&#10;                            handler.post(idleCheckerRunnable)&#10;                        } else {&#10;                            Log.d(&quot;nvm&quot;, &quot;Auto-resuming service instantly after unlock (paused by screen lock)&quot;)&#10;                            resumeService()&#10;                        }&#10;                    } else {&#10;                        Log.d(&quot;nvm&quot;, &quot;Resume not needed (isPaused=$isPaused, isRunning=$isRunning)&quot;)&#10;                    }&#10;                }&#10;                Intent.ACTION_SCREEN_ON -&gt; {&#10;                    isScreenOn = true&#10;&#10;                    // Use a short delay to let keyguard state settle&#10;                    handler.postDelayed({&#10;                        val keyguardManager = getSystemService(KEYGUARD_SERVICE) as android.app.KeyguardManager&#10;                        val isLocked = keyguardManager.isKeyguardLocked&#10;&#10;                        Log.d(&quot;nvm&quot;, &quot;Screen turned ON - isLocked: $isLocked, isVibrationServiceRunning: $isVibrationServiceRunning&quot;)&#10;&#10;                        if (!isLocked &amp;&amp; isVibrationServiceRunning) {&#10;                            // Screen is ON and unlocked - stop vibration&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen unlocked (via SCREEN_ON) - stopping vibration alert&quot;)&#10;                            stopVibrationAlert()&#10;&#10;                            // Check if user was paused by touch interaction&#10;                            if (isPaused &amp;&amp; isRunning &amp;&amp; lastUserInteractionTime &gt; 0) {&#10;                                val idleTime = System.currentTimeMillis() - lastUserInteractionTime&#10;                                val mediaPlaying = isMediaPlaying()&#10;                                val inCall = isInCall()&#10;&#10;                                if (idleTime &gt;= idleTimeout) {&#10;                                    if (mediaPlaying) {&#10;                                        Log.d(&quot;nvm&quot;, &quot;Idle timeout met but media is playing (via SCREEN_ON) - NOT resuming&quot;)&#10;                                    } else if (inCall) {&#10;                                        Log.d(&quot;nvm&quot;, &quot;Idle timeout met but in a call (via SCREEN_ON) - NOT resuming&quot;)&#10;                                    } else {&#10;                                        Log.d(&quot;nvm&quot;, &quot;Auto-resuming service after unlock (via SCREEN_ON, idle timeout met: ${idleTime}ms)&quot;)&#10;                                        resumeService()&#10;                                    }&#10;                                } else {&#10;                                    Log.d(&quot;nvm&quot;, &quot;Not resuming yet (via SCREEN_ON) - only ${idleTime}ms idle, need ${idleTimeout}ms&quot;)&#10;                                }&#10;                            } else if (isPaused &amp;&amp; isRunning &amp;&amp; lastUserInteractionTime == 0L) {&#10;                                // Service was paused by screen lock (not touch), check media and calls&#10;                                val mediaPlaying = isMediaPlaying()&#10;                                val inCall = isInCall()&#10;                                if (mediaPlaying) {&#10;                                    Log.d(&quot;nvm&quot;, &quot;Screen unlocked (via SCREEN_ON) but media is playing - NOT resuming, starting idle checker&quot;)&#10;                                    lastUserInteractionTime = System.currentTimeMillis()&#10;                                    handler.post(idleCheckerRunnable)&#10;                                } else if (inCall) {&#10;                                    Log.d(&quot;nvm&quot;, &quot;Screen unlocked (via SCREEN_ON) but in a call - NOT resuming, starting idle checker&quot;)&#10;                                    lastUserInteractionTime = System.currentTimeMillis()&#10;                                    handler.post(idleCheckerRunnable)&#10;                                } else {&#10;                                    Log.d(&quot;nvm&quot;, &quot;Auto-resuming service instantly after unlock (via SCREEN_ON, paused by screen lock)&quot;)&#10;                                    resumeService()&#10;                                }&#10;                            }&#10;                        } else if (isLocked) {&#10;                            // Screen on but still locked (wake lock keeping it on for vibration)&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen on but locked - vibration continues&quot;)&#10;                        }&#10;                    }, 500) // 500ms delay to ensure keyguard state is accurate&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private val launchRunnable = object : Runnable {&#10;        override fun run() {&#10;            Log.d(&quot;nvm&quot;, &quot;launchRunnable.run() called - isRunning=$isRunning, isPaused=$isPaused&quot;)&#10;&#10;            if (isRunning &amp;&amp; !isPaused) {&#10;                Log.d(&quot;nvm&quot;, &quot;⏰ Timer reached 0 - Executing action NOW&quot;)&#10;                handleFiverrAction()&#10;                nextLaunchTime = System.currentTimeMillis() + launchInterval&#10;&#10;                // Reset the timer to restart countdown after action&#10;                overlayView?.resetTimer()&#10;                Log.d(&quot;nvm&quot;, &quot;Timer reset after Fiverr action - countdown restarted&quot;)&#10;&#10;                // Schedule next action with full interval&#10;                handler.postDelayed(this, launchInterval)&#10;                Log.d(&quot;nvm&quot;, &quot;Next action scheduled in ${launchInterval}ms&quot;)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;⚠️ launchRunnable skipped execution - isRunning=$isRunning, isPaused=$isPaused&quot;)&#10;                // DO NOT reschedule when paused - wait for resumeService() to schedule with correct remaining time&#10;            }&#10;        }&#10;    }&#10;&#10;    // Check if user has been idle for 1 minute, then auto-resume (unless media is playing)&#10;    private val idleCheckerRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; isPaused) {&#10;                val idleTime = System.currentTimeMillis() - lastUserInteractionTime&#10;&#10;                // Check if media is playing or user is in a call&#10;                val mediaPlaying = isMediaPlaying()&#10;                val inCall = isInCall()&#10;&#10;                if (idleTime &gt;= idleTimeout) {&#10;                    if (mediaPlaying) {&#10;                        Log.d(&quot;nvm&quot;, &quot;User idle for 1 minute but media is playing - NOT resuming&quot;)&#10;                    } else if (inCall) {&#10;                        Log.d(&quot;nvm&quot;, &quot;User idle for 1 minute but in a call - NOT resuming&quot;)&#10;                    } else {&#10;                        Log.d(&quot;nvm&quot;, &quot;User idle for 1 minute, no media playing, no call - auto-resuming service&quot;)&#10;                        resumeService()&#10;                    }&#10;                }&#10;            }&#10;            if (isRunning) {&#10;                handler.postDelayed(this, 1000) // Check every second&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        // Handle null intent when service is restarted by Android after being killed&#10;        if (intent == null) {&#10;            Log.d(&quot;nvm&quot;, &quot;Service restarted by Android (null intent) - restoring from SharedPreferences&quot;)&#10;            val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;            val wasEnabled = prefs.getBoolean(&quot;service_enabled&quot;, false)&#10;            val savedInterval = prefs.getLong(&quot;service_interval&quot;, 20000L)&#10;&#10;            if (wasEnabled) {&#10;                Log.d(&quot;nvm&quot;, &quot;Restoring service with interval: ${savedInterval}ms&quot;)&#10;                launchInterval = savedInterval&#10;                startForegroundServiceInternal()&#10;                isRunning = true&#10;                handler.post(launchRunnable)&#10;                createOverlay()&#10;                acquireWakeLock()&#10;                Log.d(&quot;nvm&quot;, &quot;Service restored successfully&quot;)&#10;&#10;                // Reduce brightness when service is restored (if screen is on)&#10;                if (isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Reducing brightness on service restore&quot;)&#10;                    reduceBrightness()&#10;                }&#10;&#10;                // Check if screen is off and start vibration if needed&#10;                if (!isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Service restored with screen OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;            } else {&#10;                Log.d(&quot;nvm&quot;, &quot;Service was disabled by user, not restoring&quot;)&#10;                stopSelf()&#10;            }&#10;            return START_STICKY&#10;        }&#10;&#10;        when (intent.action) {&#10;            ACTION_START -&gt; {&#10;                // Get interval from intent, default to 20 seconds&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                // Save service state as enabled - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putBoolean(&quot;service_enabled&quot;, true)&#10;                    .putLong(&quot;service_interval&quot;, launchInterval)&#10;                    .commit() // Use commit() instead of apply() for immediate write&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Saved state: service_enabled=true, interval=${launchInterval}ms&quot;)&#10;&#10;                startForegroundServiceInternal()&#10;                isRunning = true&#10;                handler.post(launchRunnable)&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService started with interval: ${launchInterval}ms&quot;)&#10;&#10;                // Create overlay and acquire wake lock&#10;                createOverlay()&#10;                acquireWakeLock()&#10;&#10;                // Reduce brightness when service starts (if screen is on)&#10;                if (isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Reducing brightness on service start&quot;)&#10;                    reduceBrightness()&#10;                }&#10;&#10;                // Check if screen is off and start vibration if needed&#10;                if (!isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Service started with screen OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;            }&#10;            ACTION_STOP -&gt; {&#10;                isRunning = false&#10;                handler.removeCallbacks(launchRunnable)&#10;&#10;                // Save service state as disabled - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putBoolean(&quot;service_enabled&quot;, false)&#10;                    .commit() // Use commit() instead of apply()&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Saved state: service_enabled=false&quot;)&#10;&#10;                // Stop vibration, remove overlay and release wake lock&#10;                stopVibrationAlert()&#10;                removeOverlay()&#10;                releaseWakeLock()&#10;&#10;                stopForegroundServiceInternal()&#10;                Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService stopped&quot;)&#10;            }&#10;            ACTION_UPDATE_INTERVAL -&gt; {&#10;                // User finished dragging slider - update interval and resume&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                // Save updated interval - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putLong(&quot;service_interval&quot;, launchInterval)&#10;                    .commit()&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Interval updated to: ${launchInterval}ms, rescheduling handler&quot;)&#10;                // Cancel current scheduled task and reschedule with new interval&#10;                handler.removeCallbacks(launchRunnable)&#10;                if (isRunning &amp;&amp; !isPaused) {&#10;                    // If service was running (not paused), restart with new interval&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    // Schedule next action with the new interval (not immediate)&#10;                    handler.postDelayed(launchRunnable, launchInterval)&#10;                    Log.d(&quot;nvm&quot;, &quot;Handler rescheduled to run in ${launchInterval}ms&quot;)&#10;                } else if (isRunning &amp;&amp; isPaused) {&#10;                    // Service is paused - just update the timer duration&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    overlayView?.setPaused(true) // Keep it paused&#10;                }&#10;            }&#10;            ACTION_PAUSE_FOR_SLIDER -&gt; {&#10;                // User is dragging slider - pause service temporarily&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Slider interaction detected - pausing service temporarily&quot;)&#10;                if (isRunning &amp;&amp; !isPaused) {&#10;                    // Pause the service&#10;                    lastUserInteractionTime = System.currentTimeMillis()&#10;                    pauseService(startIdleChecker = false) // Don't start idle checker for slider&#10;&#10;                    // Update timer with new interval but keep it paused&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    overlayView?.setPaused(true)&#10;                } else if (isRunning &amp;&amp; isPaused) {&#10;                    // Already paused, just update timer&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    overlayView?.setPaused(true)&#10;                }&#10;            }&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun createOverlay() {&#10;        try {&#10;            windowManager = getSystemService(WINDOW_SERVICE) as WindowManager&#10;&#10;            val layoutType = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#10;            }&#10;&#10;            // Create touch detector overlay (full screen, invisible)&#10;            touchDetectorView = TouchDetectorView(this) { userTouched() }&#10;            val touchParams = WindowManager.LayoutParams(&#10;                1, // Very small, just 1 pixel&#10;                1, // Very small, just 1 pixel&#10;                layoutType,&#10;                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or&#10;                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or&#10;                        WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH or&#10;                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,&#10;                PixelFormat.TRANSLUCENT&#10;            ).apply {&#10;                gravity = Gravity.TOP or Gravity.START&#10;                x = 0&#10;                y = 0&#10;            }&#10;            windowManager?.addView(touchDetectorView, touchParams)&#10;            Log.d(&quot;nvm&quot;, &quot;Touch detector overlay created&quot;)&#10;&#10;            // Create circular timer overlay&#10;            overlayView = CircularTimerView(this)&#10;            val overlaySize = 120 // 120dp for circular timer&#10;            val params = WindowManager.LayoutParams(&#10;                overlaySize,&#10;                overlaySize,&#10;                layoutType,&#10;                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or&#10;                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or&#10;                        WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or&#10;                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,&#10;                PixelFormat.TRANSLUCENT&#10;            ).apply {&#10;                gravity = Gravity.TOP or Gravity.END&#10;                x = 20 // 20px from right edge&#10;                y = 100 // 100px from top&#10;            }&#10;&#10;            windowManager?.addView(overlayView, params)&#10;            overlayView?.startTimer(launchInterval)&#10;            Log.d(&quot;nvm&quot;, &quot;Circular timer overlay created&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error creating overlay: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun removeOverlay() {&#10;        try {&#10;            if (touchDetectorView != null) {&#10;                windowManager?.removeView(touchDetectorView)&#10;                touchDetectorView = null&#10;            }&#10;            if (overlayView != null) {&#10;                overlayView?.stopTimer()&#10;                windowManager?.removeView(overlayView)&#10;                overlayView = null&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error removing overlay: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun acquireWakeLock() {&#10;        try {&#10;            val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;            wakeLock = powerManager.newWakeLock(&#10;                PowerManager.SCREEN_DIM_WAKE_LOCK,&#10;                &quot;FiverrSupport:KeepScreenOnWakeLock&quot;&#10;            )&#10;            wakeLock?.acquire(10 * 60 * 60 * 1000L) // 10 hour timeout&#10;            Log.d(&quot;nvm&quot;, &quot;WakeLock acquired&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error acquiring wake lock: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun releaseWakeLock() {&#10;        try {&#10;            wakeLock?.release()&#10;            wakeLock = null&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error releasing wake lock: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun startForegroundServiceInternal() {&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;        Toast.makeText(this, &quot;Fiverr Support Service Started&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun stopForegroundServiceInternal() {&#10;        stopForeground(STOP_FOREGROUND_REMOVE)&#10;        stopSelf()&#10;        Toast.makeText(this, &quot;Fiverr Support Service Stopped&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun createNotification(): Notification {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, notificationIntent,&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Fiverr Support&quot;)&#10;            .setContentText(&quot;Service running - keeping screen awake &amp; opening Fiverr&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .build()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Fiverr Support Service&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Shows when Fiverr support service is running&quot;&#10;            }&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Main logic: Check if Fiverr is in foreground&#10;     * - If YES: Perform pull-down scroll gesture (via accessibility)&#10;     * - If NO: Launch/bring Fiverr to front&#10;     */&#10;    private fun handleFiverrAction() {&#10;        val fiverrPackage = &quot;com.fiverr.fiverr&quot;&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;========================================&quot;)&#10;        Log.d(&quot;nvm&quot;, &quot;Countdown reached 0 - Making decision NOW&quot;)&#10;        Log.d(&quot;nvm&quot;, &quot;Current timestamp: ${System.currentTimeMillis()}&quot;)&#10;&#10;        // Check if Fiverr app is currently in foreground RIGHT NOW&#10;        val isFiverrInFront = isAppInForeground(this, fiverrPackage)&#10;&#10;        if (isFiverrInFront) {&#10;            // Fiverr is already in front, perform scroll gesture&#10;            Log.d(&quot;nvm&quot;, &quot;✅ DECISION: Fiverr IS in foreground → Performing pull-down gesture&quot;)&#10;            performScrollGesture()&#10;        } else {&#10;            // Fiverr is not in front, launch it&#10;            Log.d(&quot;nvm&quot;, &quot;✅ DECISION: Fiverr NOT in foreground → Launching app&quot;)&#10;            launchFiverrApp()&#10;        }&#10;        Log.d(&quot;nvm&quot;, &quot;========================================&quot;)&#10;    }&#10;&#10;    /**&#10;     * Perform pull-down scroll gesture using Accessibility Service&#10;     */&#10;    private fun performScrollGesture() {&#10;        val accessibilityService = FiverrAccessibilityService.getInstance()&#10;&#10;        if (accessibilityService == null) {&#10;            Log.w(&quot;nvm&quot;, &quot;Accessibility service not available - cannot perform scroll gesture&quot;)&#10;            Toast.makeText(this, &quot;Enable accessibility service to perform auto-scroll&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Set flag to ignore touch events during automated gesture&#10;        isPerformingAutomatedGesture = true&#10;        Log.d(&quot;nvm&quot;, &quot;Starting automated gesture - touch detection disabled&quot;)&#10;&#10;        accessibilityService.performPullDownGesture { success -&gt;&#10;            if (success) {&#10;                Log.d(&quot;nvm&quot;, &quot;Pull-down gesture executed successfully&quot;)&#10;            } else {&#10;                Log.e(&quot;nvm&quot;, &quot;Failed to execute pull-down gesture&quot;)&#10;            }&#10;&#10;            // Re-enable touch detection after a short delay (gesture completion + 500ms buffer)&#10;            handler.postDelayed({&#10;                isPerformingAutomatedGesture = false&#10;                Log.d(&quot;nvm&quot;, &quot;Automated gesture completed - touch detection re-enabled&quot;)&#10;            }, 800) // 300ms gesture duration + 500ms buffer&#10;        }&#10;    }&#10;&#10;    private fun launchFiverrApp() {&#10;        try {&#10;            val intent = packageManager.getLaunchIntentForPackage(&quot;com.fiverr.fiverr&quot;)&#10;            if (intent != null) {&#10;                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)&#10;                startActivity(intent)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;Fiverr app package not found&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error launching Fiverr app: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Called when user touches the screen&#10;    private fun userTouched() {&#10;        // Ignore touch events during automated gestures&#10;        if (isPerformingAutomatedGesture) {&#10;            Log.d(&quot;nvm&quot;, &quot;Touch detected during automated gesture - ignoring&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;User touch detected - pausing service&quot;)&#10;        lastUserInteractionTime = System.currentTimeMillis()&#10;&#10;        if (!isPaused) {&#10;            pauseService()&#10;        }&#10;    }&#10;&#10;    // Pause the service (stop opening Fiverr, turn timer red)&#10;    private fun pauseService(startIdleChecker: Boolean = true) {&#10;        isPaused = true&#10;        overlayView?.setPaused(true) // Turn timer red&#10;&#10;        // Remove pending launchRunnable callbacks to prevent them from rescheduling&#10;        handler.removeCallbacks(launchRunnable)&#10;        Log.d(&quot;nvm&quot;, &quot;Removed pending launchRunnable callbacks when pausing&quot;)&#10;&#10;        // Restore brightness when paused by touch (not by screen lock)&#10;        if (startIdleChecker) {&#10;            restoreBrightness()&#10;            handler.post(idleCheckerRunnable) // Start idle checker only for touch events&#10;        }&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;Service paused ${if (startIdleChecker) &quot;with idle checker&quot; else &quot;without idle checker&quot;}&quot;)&#10;    }&#10;&#10;    // Resume the service (start opening Fiverr, turn timer green)&#10;    private fun resumeService() {&#10;        Log.d(&quot;nvm&quot;, &quot;resumeService() called - BEFORE: isRunning=$isRunning, isPaused=$isPaused&quot;)&#10;&#10;        isPaused = false&#10;&#10;        // Calculate remaining time from when it was paused&#10;        val pausedTimeMs = overlayView?.getPausedTime() ?: 0L&#10;        val remainingTime = (launchInterval - pausedTimeMs).coerceAtLeast(0)&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;Service resuming - was paused at ${pausedTimeMs}ms, remaining time: ${remainingTime}ms&quot;)&#10;        Log.d(&quot;nvm&quot;, &quot;resumeService() - AFTER isPaused=false: isRunning=$isRunning, isPaused=$isPaused&quot;)&#10;&#10;        overlayView?.setPaused(false) // Turn timer green&#10;        overlayView?.resumeTimer() // Resume from paused position (not reset!)&#10;        handler.removeCallbacks(idleCheckerRunnable) // Stop idle checker&#10;&#10;        // IMPORTANT: Remove ALL pending callbacks before rescheduling&#10;        // This prevents old scheduled callbacks from interfering with the correct remaining time&#10;        handler.removeCallbacks(launchRunnable)&#10;        Log.d(&quot;nvm&quot;, &quot;Removed all pending launchRunnable callbacks before rescheduling&quot;)&#10;&#10;        // Schedule with the REMAINING time (not full interval)&#10;        handler.postDelayed(launchRunnable, remainingTime)&#10;        Log.d(&quot;nvm&quot;, &quot;Service resumed - handler scheduled to run in ${remainingTime}ms (resumed from pause, not reset)&quot;)&#10;&#10;        // Reduce brightness to 0 when service resumes&#10;        reduceBrightness()&#10;    }&#10;&#10;    // Check if any media is currently playing (music, video, etc.)&#10;    private fun isMediaPlaying(): Boolean {&#10;        return try {&#10;            audioManager?.isMusicActive == true&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error checking media playback: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Register call state listener (handles both regular calls and VoIP)&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun registerCallStateListener() {&#10;        try {&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;                // Android 12+ (API 31+): Use TelephonyCallback&#10;                val callback = object : TelephonyCallback(), TelephonyCallback.CallStateListener {&#10;                    override fun onCallStateChanged(state: Int) {&#10;                        handleCallStateChange(state)&#10;                    }&#10;                }&#10;                telephonyManager?.registerTelephonyCallback(mainExecutor, callback)&#10;                callStateListener = callback&#10;                Log.d(&quot;nvm&quot;, &quot;Registered TelephonyCallback for call detection (Android 12+)&quot;)&#10;            } else {&#10;                // Android 11 and below: Use PhoneStateListener&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val listener = object : PhoneStateListener() {&#10;                    override fun onCallStateChanged(state: Int, phoneNumber: String?) {&#10;                        handleCallStateChange(state)&#10;                    }&#10;                }&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                telephonyManager?.listen(listener, PhoneStateListener.LISTEN_CALL_STATE)&#10;                callStateListener = listener&#10;                Log.d(&quot;nvm&quot;, &quot;Registered PhoneStateListener for call detection (Android 11-)&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to register call state listener: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Unregister call state listener&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun unregisterCallStateListener() {&#10;        try {&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;                callStateListener?.let {&#10;                    telephonyManager?.unregisterTelephonyCallback(it as TelephonyCallback)&#10;                }&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                callStateListener?.let {&#10;                    telephonyManager?.listen(it as PhoneStateListener, PhoneStateListener.LISTEN_NONE)&#10;                }&#10;            }&#10;            Log.d(&quot;nvm&quot;, &quot;Unregistered call state listener&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error unregistering call state listener: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Handle call state changes&#10;    private fun handleCallStateChange(state: Int) {&#10;        when (state) {&#10;            TelephonyManager.CALL_STATE_IDLE -&gt; {&#10;                // No call active&#10;                if (isInCall) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Call ended - isInCall = false&quot;)&#10;                    isInCall = false&#10;                    // Don't auto-resume here - let idle checker handle it&#10;                }&#10;            }&#10;            TelephonyManager.CALL_STATE_RINGING, TelephonyManager.CALL_STATE_OFFHOOK -&gt; {&#10;                // Incoming call or call in progress&#10;                if (!isInCall) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Call started (state=$state) - pausing service&quot;)&#10;                    isInCall = true&#10;&#10;                    // Pause service if not already paused&#10;                    if (!isPaused &amp;&amp; isRunning) {&#10;                        lastUserInteractionTime = System.currentTimeMillis()&#10;                        pauseService()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Check if user is currently in a call (regular phone call or VoIP call)&#10;    private fun isInCall(): Boolean {&#10;        // Method 1: Check telephony call state&#10;        val telephonyCallActive = try {&#10;            telephonyManager?.callState != TelephonyManager.CALL_STATE_IDLE&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;&#10;        // Method 2: Check TelecomManager for VoIP calls (WhatsApp, Messenger, etc.)&#10;        val voipCallActive = try {&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                // Check if we have READ_PHONE_STATE permission&#10;                if (checkSelfPermission(Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED) {&#10;                    telecomManager?.isInCall == true&#10;                } else {&#10;                    false&#10;                }&#10;            } else {&#10;                false&#10;            }&#10;        } catch (_: Exception) {&#10;            false&#10;        }&#10;&#10;        // Method 3: Check AudioManager mode (works for most VoIP apps)&#10;        val audioModeInCall = try {&#10;            val mode = audioManager?.mode&#10;            mode == AudioManager.MODE_IN_CALL || mode == AudioManager.MODE_IN_COMMUNICATION&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;&#10;        val inCall = telephonyCallActive || voipCallActive || audioModeInCall&#10;&#10;        if (inCall &amp;&amp; !isInCall) {&#10;            Log.d(&quot;nvm&quot;, &quot;Call detected: telephony=$telephonyCallActive, voip=$voipCallActive, audioMode=$audioModeInCall&quot;)&#10;        }&#10;&#10;        return inCall&#10;    }&#10;&#10;    // Save current brightness and reduce to 0&#10;    private fun reduceBrightness() {&#10;        try {&#10;            // Save original brightness only once&#10;            if (originalBrightness == -1) {&#10;                originalBrightness = Settings.System.getInt(&#10;                    contentResolver,&#10;                    Settings.System.SCREEN_BRIGHTNESS&#10;                )&#10;                Log.d(&quot;nvm&quot;, &quot;Original brightness saved: $originalBrightness&quot;)&#10;            }&#10;&#10;            // Method 1: Update Settings.System (for system-wide)&#10;            Settings.System.putInt(&#10;                contentResolver,&#10;                Settings.System.SCREEN_BRIGHTNESS,&#10;                0&#10;            )&#10;&#10;            // Method 2: Update Window brightness (CRITICAL for Android 13+)&#10;            // This makes the change take effect immediately&#10;            overlayView?.let { view -&gt;&#10;                val layoutParams = view.layoutParams as? WindowManager.LayoutParams&#10;                layoutParams?.screenBrightness = 0f // 0f = minimum brightness&#10;                windowManager?.updateViewLayout(view, layoutParams)&#10;                Log.d(&quot;nvm&quot;, &quot;Window brightness reduced to 0&quot;)&#10;            }&#10;&#10;            // Also update touch detector view&#10;            touchDetectorView?.let { view -&gt;&#10;                val layoutParams = view.layoutParams as? WindowManager.LayoutParams&#10;                layoutParams?.screenBrightness = 0f&#10;                windowManager?.updateViewLayout(view, layoutParams)&#10;            }&#10;&#10;            Log.d(&quot;nvm&quot;, &quot;Brightness reduced to 0 (Settings + Window)&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error reducing brightness: ${e.message}&quot;, e)&#10;            Log.w(&quot;nvm&quot;, &quot;WRITE_SETTINGS permission may be required&quot;)&#10;        }&#10;    }&#10;&#10;    // Restore original brightness&#10;    private fun restoreBrightness() {&#10;        try {&#10;            if (originalBrightness != -1) {&#10;                // Method 1: Restore Settings.System&#10;                Settings.System.putInt(&#10;                    contentResolver,&#10;                    Settings.System.SCREEN_BRIGHTNESS,&#10;                    originalBrightness&#10;                )&#10;&#10;                // Method 2: Restore Window brightness (CRITICAL for Android 13+)&#10;                // Use BRIGHTNESS_OVERRIDE_NONE to let system control brightness&#10;                overlayView?.let { view -&gt;&#10;                    val layoutParams = view.layoutParams as? WindowManager.LayoutParams&#10;                    layoutParams?.screenBrightness = WindowManager.LayoutParams.BRIGHTNESS_OVERRIDE_NONE&#10;                    windowManager?.updateViewLayout(view, layoutParams)&#10;                    Log.d(&quot;nvm&quot;, &quot;Window brightness restored to system default&quot;)&#10;                }&#10;&#10;                touchDetectorView?.let { view -&gt;&#10;                    val layoutParams = view.layoutParams as? WindowManager.LayoutParams&#10;                    layoutParams?.screenBrightness = WindowManager.LayoutParams.BRIGHTNESS_OVERRIDE_NONE&#10;                    windowManager?.updateViewLayout(view, layoutParams)&#10;                }&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Brightness restored to: $originalBrightness (Settings + Window)&quot;)&#10;                originalBrightness = -1 // Reset flag&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error restoring brightness: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Helper to start both vibration engines&#10;    private fun startVibrationAlert() {&#10;        try {&#10;            Log.d(&quot;nvm&quot;, &quot;startVibrationAlert() called - isRunning: $isRunning, isScreenOn: $isScreenOn&quot;)&#10;            if (isRunning) {&#10;                isVibrationServiceRunning = true // Set flag BEFORE starting service&#10;                val serviceIntent = Intent(this, VibrationService::class.java)&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    startForegroundService(serviceIntent)&#10;                } else {&#10;                    startService(serviceIntent)&#10;                }&#10;                Log.d(&quot;nvm&quot;, &quot;Started VibrationService via ${if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &quot;startForegroundService&quot; else &quot;startService&quot;}&quot;)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;Cannot start VibrationService - isRunning is false&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to start VibrationService: ${e.message}&quot;, e)&#10;            isVibrationServiceRunning = false&#10;        }&#10;    }&#10;&#10;    // Helper to stop both vibration engines&#10;    private fun stopVibrationAlert() {&#10;        try {&#10;            isVibrationServiceRunning = false // Clear flag BEFORE stopping service&#10;            stopService(Intent(this, VibrationService::class.java))&#10;            Log.d(&quot;nvm&quot;, &quot;Stopped VibrationService&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to stop VibrationService: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        super.onTaskRemoved(rootIntent)&#10;        // Service continues running even when app is removed from recents&#10;        // START_STICKY in onStartCommand ensures it restarts if killed&#10;        Log.d(&quot;nvm&quot;, &quot;App removed from recents, but service continues running&quot;)&#10;    }&#10;&#10;    @SuppressLint(&quot;ScheduleExactAlarm&quot;)&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        isRunning = false&#10;        handler.removeCallbacks(launchRunnable)&#10;        removeOverlay()&#10;        releaseWakeLock()&#10;        stopVibrationAlert()&#10;&#10;        // Unregister screen state receiver&#10;        try {&#10;            unregisterReceiver(screenStateReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error unregistering receiver: ${e.message}&quot;)&#10;        }&#10;&#10;        // Check if service was enabled by user&#10;        val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;        val wasEnabled = prefs.getBoolean(&quot;service_enabled&quot;, false)&#10;&#10;        if (wasEnabled) {&#10;            Log.d(&quot;nvm&quot;, &quot;Service destroyed but was enabled - scheduling restart&quot;)&#10;&#10;            // Use AlarmManager for reliable restart on Android 13+&#10;            try {&#10;                val alarmManager = getSystemService(ALARM_SERVICE) as AlarmManager&#10;                val restartIntent = Intent(this, ServiceRestartReceiver::class.java).apply {&#10;                    action = &quot;com.akash.fiverrsupport.ACTION_RESTART_SERVICE&quot;&#10;                    putExtra(&quot;interval&quot;, prefs.getLong(&quot;service_interval&quot;, 20000L))&#10;                }&#10;&#10;                val pendingIntent = PendingIntent.getBroadcast(&#10;                    this,&#10;                    0,&#10;                    restartIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;&#10;                // Schedule restart after 2 seconds&#10;                val triggerTime = System.currentTimeMillis() + 2000&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                )&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Restart scheduled via AlarmManager&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;nvm&quot;, &quot;Failed to schedule AlarmManager: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService destroyed&quot;)&#10;    }&#10;&#10;    companion object {&#10;        const val CHANNEL_ID = &quot;FiverrSupportChannel&quot;&#10;        const val NOTIFICATION_ID = 1&#10;        const val ACTION_START = &quot;ACTION_START&quot;&#10;        const val ACTION_STOP = &quot;ACTION_STOP&quot;&#10;        const val ACTION_UPDATE_INTERVAL = &quot;ACTION_UPDATE_INTERVAL&quot;&#10;        const val ACTION_PAUSE_FOR_SLIDER = &quot;ACTION_PAUSE_FOR_SLIDER&quot;&#10;        const val EXTRA_INTERVAL = &quot;EXTRA_INTERVAL&quot;&#10;        const val VIBRATION_CHANNEL_ID = &quot;FiverrSupportVibrationChannel&quot;&#10;        const val VIBRATION_NOTIFICATION_ID = 2&#10;        const val VIBRATION_NOTIFICATION_ID_ALT = 3&#10;    }&#10;}&#10;&#10;/**&#10; * Custom View that displays a beautiful circular countdown timer&#10; */&#10;class CircularTimerView(context: android.content.Context) : View(context) {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var totalDuration = 20000L&#10;    private var startTime = 0L&#10;    private var pausedTime = 0L&#10;    private var isRunning = false&#10;    private var isPaused = false&#10;&#10;    private val backgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#80000000&quot;) // Semi-transparent black&#10;        style = Paint.Style.FILL&#10;    }&#10;&#10;    private val progressPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#4CAF50&quot;) // Green (active)&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 8f&#10;        strokeCap = Paint.Cap.ROUND&#10;    }&#10;&#10;    private val pausedPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#F44336&quot;) // Red (paused)&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 8f&#10;        strokeCap = Paint.Cap.ROUND&#10;    }&#10;&#10;    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.WHITE&#10;        textSize = 24f&#10;        textAlign = Paint.Align.CENTER&#10;        isFakeBoldText = true&#10;    }&#10;&#10;    private val rectF = RectF()&#10;&#10;    private val updateRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; !isPaused) {&#10;                invalidate() // Trigger redraw&#10;                handler.postDelayed(this, 50) // Update every 50ms for smooth animation&#10;            } else if (isPaused) {&#10;                invalidate() // Still redraw to show paused state&#10;                handler.postDelayed(this, 50)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startTimer(duration: Long) {&#10;        totalDuration = duration&#10;        startTime = System.currentTimeMillis()&#10;        isRunning = true&#10;        isPaused = false&#10;        handler.post(updateRunnable)&#10;    }&#10;&#10;    fun stopTimer() {&#10;        isRunning = false&#10;        isPaused = false&#10;        handler.removeCallbacks(updateRunnable)&#10;    }&#10;&#10;    fun setPaused(paused: Boolean) {&#10;        if (paused &amp;&amp; !isPaused) {&#10;            // Entering pause - save current time&#10;            pausedTime = System.currentTimeMillis() - startTime&#10;            isPaused = true&#10;            Log.d(&quot;nvm&quot;, &quot;Timer paused at ${pausedTime}ms&quot;)&#10;        } else if (!paused &amp;&amp; isPaused) {&#10;            // Exiting pause - not used here, use resumeTimer instead&#10;            isPaused = false&#10;        }&#10;        invalidate()&#10;    }&#10;&#10;    fun resetTimer() {&#10;        startTime = System.currentTimeMillis()&#10;        pausedTime = 0L&#10;        isPaused = false&#10;        invalidate()&#10;    }&#10;&#10;    fun resumeTimer() {&#10;        // Resume from where it was paused&#10;        if (isPaused &amp;&amp; pausedTime &gt; 0) {&#10;            startTime = System.currentTimeMillis() - pausedTime&#10;            isPaused = false&#10;            Log.d(&quot;nvm&quot;, &quot;Timer resumed from ${pausedTime}ms (${(totalDuration - pausedTime) / 1000}s remaining)&quot;)&#10;        } else {&#10;            // If not paused or no saved time, just unpause&#10;            isPaused = false&#10;        }&#10;        invalidate()&#10;    }&#10;&#10;    fun getPausedTime(): Long {&#10;        return pausedTime&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;&#10;        val width = width.toFloat()&#10;        val height = height.toFloat()&#10;        val centerX = width / 2&#10;        val centerY = height / 2&#10;        val radius = (Math.min(width, height) / 2) - 10&#10;&#10;        // Draw background circle&#10;        canvas.drawCircle(centerX, centerY, radius, backgroundPaint)&#10;&#10;        // Calculate remaining time&#10;        val elapsed = if (isPaused) {&#10;            pausedTime // Use frozen time when paused&#10;        } else {&#10;            System.currentTimeMillis() - startTime&#10;        }&#10;        val remaining = (totalDuration - elapsed).coerceAtLeast(0)&#10;        val progress = (remaining.toFloat() / totalDuration) * 360f&#10;&#10;        // Draw progress arc&#10;        rectF.set(&#10;            centerX - radius + 5,&#10;            centerY - radius + 5,&#10;            centerX + radius - 5,&#10;            centerY + radius - 5&#10;        )&#10;&#10;        // Use red paint if paused, green if active&#10;        val paint = if (isPaused) pausedPaint else progressPaint&#10;        canvas.drawArc(rectF, -90f, progress, false, paint)&#10;&#10;        // Draw remaining time text&#10;        val seconds = (remaining / 1000).toInt()&#10;        val text = &quot;${seconds}s&quot;&#10;        canvas.drawText(text, centerX, centerY + 8, textPaint)&#10;        }&#10;    }&#10;&#10;/**&#10; * Invisible tiny overlay to detect user touches via FLAG_WATCH_OUTSIDE_TOUCH&#10; */&#10;class TouchDetectorView(&#10;    context: Context,&#10;    private val onTouch: () -&gt; Unit&#10;) : View(context) {&#10;&#10;    override fun onTouchEvent(event: MotionEvent?): Boolean {&#10;        // This will be called for outside touches due to FLAG_WATCH_OUTSIDE_TOUCH&#10;        when (event?.action) {&#10;            MotionEvent.ACTION_OUTSIDE -&gt; {&#10;                // User touched outside this tiny 1x1 view (anywhere on screen)&#10;                onTouch()&#10;            }&#10;        }&#10;        return false // Don't consume the touch event - let it pass through&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.akash.fiverrsupport&#10;&#10;import android.Manifest&#10;import android.annotation.SuppressLint&#10;import android.app.AlarmManager&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.BroadcastReceiver&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.content.pm.PackageManager&#10;import android.graphics.Canvas&#10;import android.graphics.Color&#10;import android.graphics.Paint&#10;import android.graphics.PixelFormat&#10;import android.graphics.RectF&#10;import android.media.AudioManager&#10;import android.os.Build&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.os.PowerManager&#10;import android.os.VibrationEffect&#10;import android.os.VibrationAttributes&#10;import android.os.Vibrator&#10;import android.provider.Settings&#10;import android.telecom.TelecomManager&#10;import android.telephony.PhoneStateListener&#10;import android.telephony.TelephonyCallback&#10;import android.telephony.TelephonyManager&#10;import android.util.Log&#10;import android.view.Gravity&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.WindowManager&#10;import android.widget.Toast&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;import com.akash.fiverrsupport.utils.isAppInForeground&#10;&#10;class FiverrLauncherService : Service() {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var isRunning = false&#10;    private var isPaused = false // New: Track if service is paused due to user interaction&#10;    private var launchInterval = 20000L // Default 20 seconds&#10;    private var lastUserInteractionTime = 0L&#10;    private val idleTimeout = 5000L&#10;&#10;    // Flag to ignore touch events during automated gestures&#10;    private var isPerformingAutomatedGesture = false&#10;&#10;    // Screen wake-lock components&#10;    private var windowManager: WindowManager? = null&#10;    private var overlayView: CircularTimerView? = null&#10;    private var touchDetectorView: TouchDetectorView? = null&#10;    private var wakeLock: PowerManager.WakeLock? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var isScreenOn = true&#10;    private var isVibrationServiceRunning = false // Track if we intentionally started vibration&#10;    private var originalBrightness: Int = -1 // Store original brightness to restore later&#10;&#10;    private var nextLaunchTime = 0L&#10;&#10;    // Media playback detection&#10;    private var audioManager: AudioManager? = null&#10;&#10;    // Call detection&#10;    private var telephonyManager: TelephonyManager? = null&#10;    private var telecomManager: TelecomManager? = null&#10;    private var callStateListener: Any? = null // Can be PhoneStateListener or TelephonyCallback&#10;    private var isInCall = false&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        createNotificationChannel()&#10;&#10;        // Initialize vibrator (modern API)&#10;        vibrator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            getSystemService(Vibrator::class.java)&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            getSystemService(VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        // Initialize AudioManager for media playback detection&#10;        audioManager = getSystemService(AUDIO_SERVICE) as AudioManager&#10;&#10;        // Initialize TelephonyManager and TelecomManager for call detection&#10;        telephonyManager = getSystemService(TELEPHONY_SERVICE) as TelephonyManager&#10;        telecomManager = getSystemService(TELECOM_SERVICE) as TelecomManager&#10;&#10;        // Register call state listener&#10;        registerCallStateListener()&#10;&#10;        // Register screen state receiver&#10;        val filter = IntentFilter().apply {&#10;            addAction(Intent.ACTION_SCREEN_ON)&#10;            addAction(Intent.ACTION_SCREEN_OFF)&#10;            addAction(Intent.ACTION_USER_PRESENT) // Fires when user unlocks device&#10;        }&#10;        registerReceiver(screenStateReceiver, filter)&#10;&#10;        // Check current screen state&#10;        val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;        isScreenOn = powerManager.isInteractive&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;Service created, screen is ${if (isScreenOn) &quot;ON&quot; else &quot;OFF&quot;}&quot;)&#10;    }&#10;&#10;    // Screen state receiver to detect screen on/off&#10;    private val screenStateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                Intent.ACTION_SCREEN_OFF -&gt; {&#10;                    isScreenOn = false&#10;                    Log.d(&quot;nvm&quot;, &quot;Screen turned OFF - pausing service and starting vibration&quot;)&#10;&#10;                    // Pause the service (like touch does) but without idle checker&#10;                    // We'll resume after unlock instead&#10;                    if (!isPaused &amp;&amp; isRunning) {&#10;                        // Reset lastUserInteractionTime to 0 to mark this as &quot;paused by screen lock&quot;&#10;                        lastUserInteractionTime = 0&#10;                        pauseService(startIdleChecker = false) // Don't start idle checker for screen lock&#10;                        Log.d(&quot;nvm&quot;, &quot;Service paused due to screen lock (lastUserInteractionTime reset to 0)&quot;)&#10;                    }&#10;&#10;                    // Start vibration alert&#10;                    startVibrationAlert()&#10;                }&#10;                Intent.ACTION_USER_PRESENT -&gt; {&#10;                    // USER_PRESENT fires when user unlocks the device (most reliable)&#10;                    isScreenOn = true&#10;                    Log.d(&quot;nvm&quot;, &quot;USER_PRESENT received - user unlocked device&quot;)&#10;&#10;                    // Stop vibration&#10;                    if (isVibrationServiceRunning) {&#10;                        Log.d(&quot;nvm&quot;, &quot;Stopping vibration after unlock&quot;)&#10;                        stopVibrationAlert()&#10;                    }&#10;&#10;                    // Check if user was paused by touch interaction (idle checker is running)&#10;                    // If so, respect the 1-minute idle timeout instead of instant resume&#10;                    if (isPaused &amp;&amp; isRunning &amp;&amp; lastUserInteractionTime &gt; 0) {&#10;                        val idleTime = System.currentTimeMillis() - lastUserInteractionTime&#10;                        val mediaPlaying = isMediaPlaying()&#10;                        val inCall = isInCall()&#10;&#10;                        if (idleTime &gt;= idleTimeout) {&#10;                            if (mediaPlaying) {&#10;                                Log.d(&quot;nvm&quot;, &quot;Idle timeout met but media is playing - NOT resuming&quot;)&#10;                            } else if (inCall) {&#10;                                Log.d(&quot;nvm&quot;, &quot;Idle timeout met but in a call - NOT resuming&quot;)&#10;                            } else {&#10;                                Log.d(&quot;nvm&quot;, &quot;Auto-resuming service after unlock (idle timeout met: ${idleTime}ms)&quot;)&#10;                                resumeService()&#10;                            }&#10;                        } else {&#10;                            Log.d(&quot;nvm&quot;, &quot;Not resuming yet - only ${idleTime}ms idle, need ${idleTimeout}ms (${idleTimeout - idleTime}ms remaining)&quot;)&#10;                            // Don't resume - let idle checker continue&#10;                        }&#10;                    } else if (isPaused &amp;&amp; isRunning &amp;&amp; lastUserInteractionTime == 0L) {&#10;                        // Service was paused by screen lock (not touch), so resume instantly&#10;                        // But still check for media playback and calls&#10;                        val mediaPlaying = isMediaPlaying()&#10;                        val inCall = isInCall()&#10;                        if (mediaPlaying) {&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen unlocked but media is playing - NOT resuming, starting idle checker&quot;)&#10;                            // Start idle checker to wait for media to stop&#10;                            lastUserInteractionTime = System.currentTimeMillis()&#10;                            handler.post(idleCheckerRunnable)&#10;                        } else if (inCall) {&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen unlocked but in a call - NOT resuming, starting idle checker&quot;)&#10;                            // Start idle checker to wait for call to end&#10;                            lastUserInteractionTime = System.currentTimeMillis()&#10;                            handler.post(idleCheckerRunnable)&#10;                        } else {&#10;                            Log.d(&quot;nvm&quot;, &quot;Auto-resuming service instantly after unlock (paused by screen lock)&quot;)&#10;                            resumeService()&#10;                        }&#10;                    } else {&#10;                        Log.d(&quot;nvm&quot;, &quot;Resume not needed (isPaused=$isPaused, isRunning=$isRunning)&quot;)&#10;                    }&#10;                }&#10;                Intent.ACTION_SCREEN_ON -&gt; {&#10;                    isScreenOn = true&#10;&#10;                    // Use a short delay to let keyguard state settle&#10;                    handler.postDelayed({&#10;                        val keyguardManager = getSystemService(KEYGUARD_SERVICE) as android.app.KeyguardManager&#10;                        val isLocked = keyguardManager.isKeyguardLocked&#10;&#10;                        Log.d(&quot;nvm&quot;, &quot;Screen turned ON - isLocked: $isLocked, isVibrationServiceRunning: $isVibrationServiceRunning&quot;)&#10;&#10;                        if (!isLocked &amp;&amp; isVibrationServiceRunning) {&#10;                            // Screen is ON and unlocked - stop vibration&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen unlocked (via SCREEN_ON) - stopping vibration alert&quot;)&#10;                            stopVibrationAlert()&#10;&#10;                            // Check if user was paused by touch interaction&#10;                            if (isPaused &amp;&amp; isRunning &amp;&amp; lastUserInteractionTime &gt; 0) {&#10;                                val idleTime = System.currentTimeMillis() - lastUserInteractionTime&#10;                                val mediaPlaying = isMediaPlaying()&#10;                                val inCall = isInCall()&#10;&#10;                                if (idleTime &gt;= idleTimeout) {&#10;                                    if (mediaPlaying) {&#10;                                        Log.d(&quot;nvm&quot;, &quot;Idle timeout met but media is playing (via SCREEN_ON) - NOT resuming&quot;)&#10;                                    } else if (inCall) {&#10;                                        Log.d(&quot;nvm&quot;, &quot;Idle timeout met but in a call (via SCREEN_ON) - NOT resuming&quot;)&#10;                                    } else {&#10;                                        Log.d(&quot;nvm&quot;, &quot;Auto-resuming service after unlock (via SCREEN_ON, idle timeout met: ${idleTime}ms)&quot;)&#10;                                        resumeService()&#10;                                    }&#10;                                } else {&#10;                                    Log.d(&quot;nvm&quot;, &quot;Not resuming yet (via SCREEN_ON) - only ${idleTime}ms idle, need ${idleTimeout}ms&quot;)&#10;                                }&#10;                            } else if (isPaused &amp;&amp; isRunning &amp;&amp; lastUserInteractionTime == 0L) {&#10;                                // Service was paused by screen lock (not touch), check media and calls&#10;                                val mediaPlaying = isMediaPlaying()&#10;                                val inCall = isInCall()&#10;                                if (mediaPlaying) {&#10;                                    Log.d(&quot;nvm&quot;, &quot;Screen unlocked (via SCREEN_ON) but media is playing - NOT resuming, starting idle checker&quot;)&#10;                                    lastUserInteractionTime = System.currentTimeMillis()&#10;                                    handler.post(idleCheckerRunnable)&#10;                                } else if (inCall) {&#10;                                    Log.d(&quot;nvm&quot;, &quot;Screen unlocked (via SCREEN_ON) but in a call - NOT resuming, starting idle checker&quot;)&#10;                                    lastUserInteractionTime = System.currentTimeMillis()&#10;                                    handler.post(idleCheckerRunnable)&#10;                                } else {&#10;                                    Log.d(&quot;nvm&quot;, &quot;Auto-resuming service instantly after unlock (via SCREEN_ON, paused by screen lock)&quot;)&#10;                                    resumeService()&#10;                                }&#10;                            }&#10;                        } else if (isLocked) {&#10;                            // Screen on but still locked (wake lock keeping it on for vibration)&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen on but locked - vibration continues&quot;)&#10;                        }&#10;                    }, 500) // 500ms delay to ensure keyguard state is accurate&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private val launchRunnable = object : Runnable {&#10;        override fun run() {&#10;            Log.d(&quot;nvm&quot;, &quot;launchRunnable.run() called - isRunning=$isRunning, isPaused=$isPaused&quot;)&#10;&#10;            if (isRunning &amp;&amp; !isPaused) {&#10;                Log.d(&quot;nvm&quot;, &quot;⏰ Timer reached 0 - Executing action NOW&quot;)&#10;                handleFiverrAction()&#10;                nextLaunchTime = System.currentTimeMillis() + launchInterval&#10;&#10;                // Reset the timer to restart countdown after action&#10;                overlayView?.resetTimer()&#10;                Log.d(&quot;nvm&quot;, &quot;Timer reset after Fiverr action - countdown restarted&quot;)&#10;&#10;                // Schedule next action with full interval&#10;                handler.postDelayed(this, launchInterval)&#10;                Log.d(&quot;nvm&quot;, &quot;Next action scheduled in ${launchInterval}ms&quot;)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;⚠️ launchRunnable skipped execution - isRunning=$isRunning, isPaused=$isPaused&quot;)&#10;                // DO NOT reschedule when paused - wait for resumeService() to schedule with correct remaining time&#10;            }&#10;        }&#10;    }&#10;&#10;    // Check if user has been idle for 1 minute, then auto-resume (unless media is playing)&#10;    private val idleCheckerRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; isPaused) {&#10;                val idleTime = System.currentTimeMillis() - lastUserInteractionTime&#10;&#10;                // Check if media is playing or user is in a call&#10;                val mediaPlaying = isMediaPlaying()&#10;                val inCall = isInCall()&#10;&#10;                if (idleTime &gt;= idleTimeout) {&#10;                    if (mediaPlaying) {&#10;                        Log.d(&quot;nvm&quot;, &quot;User idle for 1 minute but media is playing - NOT resuming&quot;)&#10;                    } else if (inCall) {&#10;                        Log.d(&quot;nvm&quot;, &quot;User idle for 1 minute but in a call - NOT resuming&quot;)&#10;                    } else {&#10;                        Log.d(&quot;nvm&quot;, &quot;User idle for 1 minute, no media playing, no call - auto-resuming service&quot;)&#10;                        resumeService()&#10;                    }&#10;                }&#10;            }&#10;            if (isRunning) {&#10;                handler.postDelayed(this, 1000) // Check every second&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        // Handle null intent when service is restarted by Android after being killed&#10;        if (intent == null) {&#10;            Log.d(&quot;nvm&quot;, &quot;Service restarted by Android (null intent) - restoring from SharedPreferences&quot;)&#10;            val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;            val wasEnabled = prefs.getBoolean(&quot;service_enabled&quot;, false)&#10;            val savedInterval = prefs.getLong(&quot;service_interval&quot;, 20000L)&#10;&#10;            if (wasEnabled) {&#10;                Log.d(&quot;nvm&quot;, &quot;Restoring service with interval: ${savedInterval}ms&quot;)&#10;                launchInterval = savedInterval&#10;                startForegroundServiceInternal()&#10;                isRunning = true&#10;                handler.post(launchRunnable)&#10;                createOverlay()&#10;                acquireWakeLock()&#10;                Log.d(&quot;nvm&quot;, &quot;Service restored successfully&quot;)&#10;&#10;                // Reduce brightness when service is restored (if screen is on)&#10;                if (isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Reducing brightness on service restore&quot;)&#10;                    reduceBrightness()&#10;                }&#10;&#10;                // Check if screen is off and start vibration if needed&#10;                if (!isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Service restored with screen OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;            } else {&#10;                Log.d(&quot;nvm&quot;, &quot;Service was disabled by user, not restoring&quot;)&#10;                stopSelf()&#10;            }&#10;            return START_STICKY&#10;        }&#10;&#10;        when (intent.action) {&#10;            ACTION_START -&gt; {&#10;                // Get interval from intent, default to 20 seconds&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                // Save service state as enabled - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putBoolean(&quot;service_enabled&quot;, true)&#10;                    .putLong(&quot;service_interval&quot;, launchInterval)&#10;                    .commit() // Use commit() instead of apply() for immediate write&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Saved state: service_enabled=true, interval=${launchInterval}ms&quot;)&#10;&#10;                startForegroundServiceInternal()&#10;                isRunning = true&#10;                handler.post(launchRunnable)&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService started with interval: ${launchInterval}ms&quot;)&#10;&#10;                // Create overlay and acquire wake lock&#10;                createOverlay()&#10;                acquireWakeLock()&#10;&#10;                // Reduce brightness when service starts (if screen is on)&#10;                if (isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Reducing brightness on service start&quot;)&#10;                    reduceBrightness()&#10;                }&#10;&#10;                // Check if screen is off and start vibration if needed&#10;                if (!isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Service started with screen OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;            }&#10;            ACTION_STOP -&gt; {&#10;                isRunning = false&#10;                handler.removeCallbacks(launchRunnable)&#10;&#10;                // Save service state as disabled - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putBoolean(&quot;service_enabled&quot;, false)&#10;                    .commit() // Use commit() instead of apply()&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Saved state: service_enabled=false&quot;)&#10;&#10;                // Stop vibration, remove overlay and release wake lock&#10;                stopVibrationAlert()&#10;                removeOverlay()&#10;                releaseWakeLock()&#10;&#10;                stopForegroundServiceInternal()&#10;                Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService stopped&quot;)&#10;            }&#10;            ACTION_UPDATE_INTERVAL -&gt; {&#10;                // User finished dragging slider - update interval and resume&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                // Save updated interval - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putLong(&quot;service_interval&quot;, launchInterval)&#10;                    .commit()&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Interval updated to: ${launchInterval}ms, rescheduling handler&quot;)&#10;                // Cancel current scheduled task and reschedule with new interval&#10;                handler.removeCallbacks(launchRunnable)&#10;                if (isRunning &amp;&amp; !isPaused) {&#10;                    // If service was running (not paused), restart with new interval&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    // Schedule next action with the new interval (not immediate)&#10;                    handler.postDelayed(launchRunnable, launchInterval)&#10;                    Log.d(&quot;nvm&quot;, &quot;Handler rescheduled to run in ${launchInterval}ms&quot;)&#10;                } else if (isRunning &amp;&amp; isPaused) {&#10;                    // Service is paused - just update the timer duration&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    overlayView?.setPaused(true) // Keep it paused&#10;                }&#10;            }&#10;            ACTION_PAUSE_FOR_SLIDER -&gt; {&#10;                // User is dragging slider - pause service temporarily&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Slider interaction detected - pausing service temporarily&quot;)&#10;                if (isRunning &amp;&amp; !isPaused) {&#10;                    // Pause the service&#10;                    lastUserInteractionTime = System.currentTimeMillis()&#10;                    pauseService(startIdleChecker = false) // Don't start idle checker for slider&#10;&#10;                    // Update timer with new interval but keep it paused&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    overlayView?.setPaused(true)&#10;                } else if (isRunning &amp;&amp; isPaused) {&#10;                    // Already paused, just update timer&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    overlayView?.setPaused(true)&#10;                }&#10;            }&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun createOverlay() {&#10;        try {&#10;            windowManager = getSystemService(WINDOW_SERVICE) as WindowManager&#10;&#10;            val layoutType = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#10;            }&#10;&#10;            // Create touch detector overlay (full screen, invisible)&#10;            touchDetectorView = TouchDetectorView(this) { userTouched() }&#10;            val touchParams = WindowManager.LayoutParams(&#10;                1, // Very small, just 1 pixel&#10;                1, // Very small, just 1 pixel&#10;                layoutType,&#10;                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or&#10;                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or&#10;                        WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH or&#10;                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,&#10;                PixelFormat.TRANSLUCENT&#10;            ).apply {&#10;                gravity = Gravity.TOP or Gravity.START&#10;                x = 0&#10;                y = 0&#10;            }&#10;            windowManager?.addView(touchDetectorView, touchParams)&#10;            Log.d(&quot;nvm&quot;, &quot;Touch detector overlay created&quot;)&#10;&#10;            // Create circular timer overlay&#10;            overlayView = CircularTimerView(this)&#10;            val overlaySize = 120 // 120dp for circular timer&#10;            val params = WindowManager.LayoutParams(&#10;                overlaySize,&#10;                overlaySize,&#10;                layoutType,&#10;                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or&#10;                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or&#10;                        WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or&#10;                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,&#10;                PixelFormat.TRANSLUCENT&#10;            ).apply {&#10;                gravity = Gravity.TOP or Gravity.END&#10;                x = 20 // 20px from right edge&#10;                y = 100 // 100px from top&#10;            }&#10;&#10;            windowManager?.addView(overlayView, params)&#10;            overlayView?.startTimer(launchInterval)&#10;            Log.d(&quot;nvm&quot;, &quot;Circular timer overlay created&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error creating overlay: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun removeOverlay() {&#10;        try {&#10;            if (touchDetectorView != null) {&#10;                windowManager?.removeView(touchDetectorView)&#10;                touchDetectorView = null&#10;            }&#10;            if (overlayView != null) {&#10;                overlayView?.stopTimer()&#10;                windowManager?.removeView(overlayView)&#10;                overlayView = null&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error removing overlay: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun acquireWakeLock() {&#10;        try {&#10;            val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;            wakeLock = powerManager.newWakeLock(&#10;                PowerManager.SCREEN_DIM_WAKE_LOCK,&#10;                &quot;FiverrSupport:KeepScreenOnWakeLock&quot;&#10;            )&#10;            wakeLock?.acquire(10 * 60 * 60 * 1000L) // 10 hour timeout&#10;            Log.d(&quot;nvm&quot;, &quot;WakeLock acquired&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error acquiring wake lock: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun releaseWakeLock() {&#10;        try {&#10;            wakeLock?.release()&#10;            wakeLock = null&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error releasing wake lock: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun startForegroundServiceInternal() {&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;        Toast.makeText(this, &quot;Fiverr Support Service Started&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun stopForegroundServiceInternal() {&#10;        stopForeground(STOP_FOREGROUND_REMOVE)&#10;        stopSelf()&#10;        Toast.makeText(this, &quot;Fiverr Support Service Stopped&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun createNotification(): Notification {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, notificationIntent,&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Fiverr Support&quot;)&#10;            .setContentText(&quot;Service running - keeping screen awake &amp; opening Fiverr&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .build()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Fiverr Support Service&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Shows when Fiverr support service is running&quot;&#10;            }&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Main logic: Check if Fiverr is in foreground&#10;     * - If YES: Perform pull-down scroll gesture (via accessibility)&#10;     * - If NO: Launch/bring Fiverr to front&#10;     */&#10;    private fun handleFiverrAction() {&#10;        val fiverrPackage = &quot;com.fiverr.fiverr&quot;&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;========================================&quot;)&#10;        Log.d(&quot;nvm&quot;, &quot;Countdown reached 0 - Making decision NOW&quot;)&#10;        Log.d(&quot;nvm&quot;, &quot;Current timestamp: ${System.currentTimeMillis()}&quot;)&#10;&#10;        // Check if Fiverr app is currently in foreground RIGHT NOW&#10;        val isFiverrInFront = isAppInForeground(this, fiverrPackage)&#10;&#10;        if (isFiverrInFront) {&#10;            // Fiverr is already in front, perform scroll gesture&#10;            Log.d(&quot;nvm&quot;, &quot;✅ DECISION: Fiverr IS in foreground → Performing pull-down gesture&quot;)&#10;            performScrollGesture()&#10;        } else {&#10;            // Fiverr is not in front, launch it&#10;            Log.d(&quot;nvm&quot;, &quot;✅ DECISION: Fiverr NOT in foreground → Launching app&quot;)&#10;            launchFiverrApp()&#10;        }&#10;        Log.d(&quot;nvm&quot;, &quot;========================================&quot;)&#10;    }&#10;&#10;    /**&#10;     * Perform pull-down scroll gesture using Accessibility Service&#10;     */&#10;    private fun performScrollGesture() {&#10;        val accessibilityService = FiverrAccessibilityService.getInstance()&#10;&#10;        if (accessibilityService == null) {&#10;            Log.w(&quot;nvm&quot;, &quot;Accessibility service not available - cannot perform scroll gesture&quot;)&#10;            Toast.makeText(this, &quot;Enable accessibility service to perform auto-scroll&quot;, Toast.LENGTH_SHORT).show()&#10;            return&#10;        }&#10;&#10;        // Set flag to ignore touch events during automated gesture&#10;        isPerformingAutomatedGesture = true&#10;        Log.d(&quot;nvm&quot;, &quot;Starting automated gesture - touch detection disabled&quot;)&#10;&#10;        accessibilityService.performPullDownGesture { success -&gt;&#10;            if (success) {&#10;                Log.d(&quot;nvm&quot;, &quot;Pull-down gesture executed successfully&quot;)&#10;            } else {&#10;                Log.e(&quot;nvm&quot;, &quot;Failed to execute pull-down gesture&quot;)&#10;            }&#10;&#10;            // Re-enable touch detection after a short delay (gesture completion + 500ms buffer)&#10;            handler.postDelayed({&#10;                isPerformingAutomatedGesture = false&#10;                Log.d(&quot;nvm&quot;, &quot;Automated gesture completed - touch detection re-enabled&quot;)&#10;            }, 800) // 300ms gesture duration + 500ms buffer&#10;        }&#10;    }&#10;&#10;    private fun launchFiverrApp() {&#10;        try {&#10;            val intent = packageManager.getLaunchIntentForPackage(&quot;com.fiverr.fiverr&quot;)&#10;            if (intent != null) {&#10;                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)&#10;                startActivity(intent)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;Fiverr app package not found&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error launching Fiverr app: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Called when user touches the screen&#10;    private fun userTouched() {&#10;        // Ignore touch events during automated gestures&#10;        if (isPerformingAutomatedGesture) {&#10;            Log.d(&quot;nvm&quot;, &quot;Touch detected during automated gesture - ignoring&quot;)&#10;            return&#10;        }&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;User touch detected - pausing service&quot;)&#10;        lastUserInteractionTime = System.currentTimeMillis()&#10;&#10;        if (!isPaused) {&#10;            pauseService()&#10;        }&#10;    }&#10;&#10;    // Pause the service (stop opening Fiverr, turn timer red)&#10;    private fun pauseService(startIdleChecker: Boolean = true) {&#10;        isPaused = true&#10;        overlayView?.setPaused(true) // Turn timer red&#10;&#10;        // Remove pending launchRunnable callbacks to prevent them from rescheduling&#10;        handler.removeCallbacks(launchRunnable)&#10;        Log.d(&quot;nvm&quot;, &quot;Removed pending launchRunnable callbacks when pausing&quot;)&#10;&#10;        // Restore brightness when paused by touch (not by screen lock)&#10;        if (startIdleChecker) {&#10;            restoreBrightness()&#10;            handler.post(idleCheckerRunnable) // Start idle checker only for touch events&#10;        }&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;Service paused ${if (startIdleChecker) &quot;with idle checker&quot; else &quot;without idle checker&quot;}&quot;)&#10;    }&#10;&#10;    // Resume the service (start opening Fiverr, turn timer green)&#10;    private fun resumeService() {&#10;        Log.d(&quot;nvm&quot;, &quot;resumeService() called - BEFORE: isRunning=$isRunning, isPaused=$isPaused&quot;)&#10;&#10;        // Calculate remaining time from when it was paused&#10;        val pausedTimeMs = overlayView?.getPausedTime() ?: 0L&#10;        val remainingTime = (launchInterval - pausedTimeMs).coerceAtLeast(0)&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;Service resuming - was paused at ${pausedTimeMs}ms, remaining time: ${remainingTime}ms&quot;)&#10;&#10;        // IMPORTANT: Call resumeTimer() first - it will handle unpausing internally&#10;        // Don't call setPaused(false) before resumeTimer() as it breaks the resume logic&#10;        overlayView?.resumeTimer() // Resume from paused position (not reset!) and unpause&#10;        &#10;        isPaused = false&#10;        Log.d(&quot;nvm&quot;, &quot;resumeService() - AFTER isPaused=false: isRunning=$isRunning, isPaused=$isPaused&quot;)&#10;&#10;        handler.removeCallbacks(idleCheckerRunnable) // Stop idle checker&#10;&#10;        // IMPORTANT: Remove ALL pending callbacks before rescheduling&#10;        // This prevents old scheduled callbacks from interfering with the correct remaining time&#10;        handler.removeCallbacks(launchRunnable)&#10;        Log.d(&quot;nvm&quot;, &quot;Removed all pending launchRunnable callbacks before rescheduling&quot;)&#10;&#10;        // Schedule with the REMAINING time (not full interval)&#10;        handler.postDelayed(launchRunnable, remainingTime)&#10;        Log.d(&quot;nvm&quot;, &quot;Service resumed - handler scheduled to run in ${remainingTime}ms (resumed from pause, not reset)&quot;)&#10;&#10;        // Reduce brightness to 0 when service resumes&#10;        reduceBrightness()&#10;    }&#10;&#10;    // Check if any media is currently playing (music, video, etc.)&#10;    private fun isMediaPlaying(): Boolean {&#10;        return try {&#10;            audioManager?.isMusicActive == true&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error checking media playback: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    // Register call state listener (handles both regular calls and VoIP)&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun registerCallStateListener() {&#10;        try {&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;                // Android 12+ (API 31+): Use TelephonyCallback&#10;                val callback = object : TelephonyCallback(), TelephonyCallback.CallStateListener {&#10;                    override fun onCallStateChanged(state: Int) {&#10;                        handleCallStateChange(state)&#10;                    }&#10;                }&#10;                telephonyManager?.registerTelephonyCallback(mainExecutor, callback)&#10;                callStateListener = callback&#10;                Log.d(&quot;nvm&quot;, &quot;Registered TelephonyCallback for call detection (Android 12+)&quot;)&#10;            } else {&#10;                // Android 11 and below: Use PhoneStateListener&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val listener = object : PhoneStateListener() {&#10;                    override fun onCallStateChanged(state: Int, phoneNumber: String?) {&#10;                        handleCallStateChange(state)&#10;                    }&#10;                }&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                telephonyManager?.listen(listener, PhoneStateListener.LISTEN_CALL_STATE)&#10;                callStateListener = listener&#10;                Log.d(&quot;nvm&quot;, &quot;Registered PhoneStateListener for call detection (Android 11-)&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to register call state listener: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Unregister call state listener&#10;    @SuppressLint(&quot;MissingPermission&quot;)&#10;    private fun unregisterCallStateListener() {&#10;        try {&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S) {&#10;                callStateListener?.let {&#10;                    telephonyManager?.unregisterTelephonyCallback(it as TelephonyCallback)&#10;                }&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                callStateListener?.let {&#10;                    telephonyManager?.listen(it as PhoneStateListener, PhoneStateListener.LISTEN_NONE)&#10;                }&#10;            }&#10;            Log.d(&quot;nvm&quot;, &quot;Unregistered call state listener&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error unregistering call state listener: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Handle call state changes&#10;    private fun handleCallStateChange(state: Int) {&#10;        when (state) {&#10;            TelephonyManager.CALL_STATE_IDLE -&gt; {&#10;                // No call active&#10;                if (isInCall) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Call ended - isInCall = false&quot;)&#10;                    isInCall = false&#10;                    // Don't auto-resume here - let idle checker handle it&#10;                }&#10;            }&#10;            TelephonyManager.CALL_STATE_RINGING, TelephonyManager.CALL_STATE_OFFHOOK -&gt; {&#10;                // Incoming call or call in progress&#10;                if (!isInCall) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Call started (state=$state) - pausing service&quot;)&#10;                    isInCall = true&#10;&#10;                    // Pause service if not already paused&#10;                    if (!isPaused &amp;&amp; isRunning) {&#10;                        lastUserInteractionTime = System.currentTimeMillis()&#10;                        pauseService()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Check if user is currently in a call (regular phone call or VoIP call)&#10;    private fun isInCall(): Boolean {&#10;        // Method 1: Check telephony call state&#10;        val telephonyCallActive = try {&#10;            telephonyManager?.callState != TelephonyManager.CALL_STATE_IDLE&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;&#10;        // Method 2: Check TelecomManager for VoIP calls (WhatsApp, Messenger, etc.)&#10;        val voipCallActive = try {&#10;            if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;                // Check if we have READ_PHONE_STATE permission&#10;                if (checkSelfPermission(Manifest.permission.READ_PHONE_STATE) == PackageManager.PERMISSION_GRANTED) {&#10;                    telecomManager?.isInCall == true&#10;                } else {&#10;                    false&#10;                }&#10;            } else {&#10;                false&#10;            }&#10;        } catch (_: Exception) {&#10;            false&#10;        }&#10;&#10;        // Method 3: Check AudioManager mode (works for most VoIP apps)&#10;        val audioModeInCall = try {&#10;            val mode = audioManager?.mode&#10;            mode == AudioManager.MODE_IN_CALL || mode == AudioManager.MODE_IN_COMMUNICATION&#10;        } catch (e: Exception) {&#10;            false&#10;        }&#10;&#10;        val inCall = telephonyCallActive || voipCallActive || audioModeInCall&#10;&#10;        if (inCall &amp;&amp; !isInCall) {&#10;            Log.d(&quot;nvm&quot;, &quot;Call detected: telephony=$telephonyCallActive, voip=$voipCallActive, audioMode=$audioModeInCall&quot;)&#10;        }&#10;&#10;        return inCall&#10;    }&#10;&#10;    // Save current brightness and reduce to 0&#10;    private fun reduceBrightness() {&#10;        try {&#10;            // Save original brightness only once&#10;            if (originalBrightness == -1) {&#10;                originalBrightness = Settings.System.getInt(&#10;                    contentResolver,&#10;                    Settings.System.SCREEN_BRIGHTNESS&#10;                )&#10;                Log.d(&quot;nvm&quot;, &quot;Original brightness saved: $originalBrightness&quot;)&#10;            }&#10;&#10;            // Method 1: Update Settings.System (for system-wide)&#10;            Settings.System.putInt(&#10;                contentResolver,&#10;                Settings.System.SCREEN_BRIGHTNESS,&#10;                0&#10;            )&#10;&#10;            // Method 2: Update Window brightness (CRITICAL for Android 13+)&#10;            // This makes the change take effect immediately&#10;            overlayView?.let { view -&gt;&#10;                val layoutParams = view.layoutParams as? WindowManager.LayoutParams&#10;                layoutParams?.screenBrightness = 0f // 0f = minimum brightness&#10;                windowManager?.updateViewLayout(view, layoutParams)&#10;                Log.d(&quot;nvm&quot;, &quot;Window brightness reduced to 0&quot;)&#10;            }&#10;&#10;            // Also update touch detector view&#10;            touchDetectorView?.let { view -&gt;&#10;                val layoutParams = view.layoutParams as? WindowManager.LayoutParams&#10;                layoutParams?.screenBrightness = 0f&#10;                windowManager?.updateViewLayout(view, layoutParams)&#10;            }&#10;&#10;            Log.d(&quot;nvm&quot;, &quot;Brightness reduced to 0 (Settings + Window)&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error reducing brightness: ${e.message}&quot;, e)&#10;            Log.w(&quot;nvm&quot;, &quot;WRITE_SETTINGS permission may be required&quot;)&#10;        }&#10;    }&#10;&#10;    // Restore original brightness&#10;    private fun restoreBrightness() {&#10;        try {&#10;            if (originalBrightness != -1) {&#10;                // Method 1: Restore Settings.System&#10;                Settings.System.putInt(&#10;                    contentResolver,&#10;                    Settings.System.SCREEN_BRIGHTNESS,&#10;                    originalBrightness&#10;                )&#10;&#10;                // Method 2: Restore Window brightness (CRITICAL for Android 13+)&#10;                // Use BRIGHTNESS_OVERRIDE_NONE to let system control brightness&#10;                overlayView?.let { view -&gt;&#10;                    val layoutParams = view.layoutParams as? WindowManager.LayoutParams&#10;                    layoutParams?.screenBrightness = WindowManager.LayoutParams.BRIGHTNESS_OVERRIDE_NONE&#10;                    windowManager?.updateViewLayout(view, layoutParams)&#10;                    Log.d(&quot;nvm&quot;, &quot;Window brightness restored to system default&quot;)&#10;                }&#10;&#10;                touchDetectorView?.let { view -&gt;&#10;                    val layoutParams = view.layoutParams as? WindowManager.LayoutParams&#10;                    layoutParams?.screenBrightness = WindowManager.LayoutParams.BRIGHTNESS_OVERRIDE_NONE&#10;                    windowManager?.updateViewLayout(view, layoutParams)&#10;                }&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Brightness restored to: $originalBrightness (Settings + Window)&quot;)&#10;                originalBrightness = -1 // Reset flag&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error restoring brightness: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    // Helper to start both vibration engines&#10;    private fun startVibrationAlert() {&#10;        try {&#10;            Log.d(&quot;nvm&quot;, &quot;startVibrationAlert() called - isRunning: $isRunning, isScreenOn: $isScreenOn&quot;)&#10;            if (isRunning) {&#10;                isVibrationServiceRunning = true // Set flag BEFORE starting service&#10;                val serviceIntent = Intent(this, VibrationService::class.java)&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    startForegroundService(serviceIntent)&#10;                } else {&#10;                    startService(serviceIntent)&#10;                }&#10;                Log.d(&quot;nvm&quot;, &quot;Started VibrationService via ${if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &quot;startForegroundService&quot; else &quot;startService&quot;}&quot;)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;Cannot start VibrationService - isRunning is false&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to start VibrationService: ${e.message}&quot;, e)&#10;            isVibrationServiceRunning = false&#10;        }&#10;    }&#10;&#10;    // Helper to stop both vibration engines&#10;    private fun stopVibrationAlert() {&#10;        try {&#10;            isVibrationServiceRunning = false // Clear flag BEFORE stopping service&#10;            stopService(Intent(this, VibrationService::class.java))&#10;            Log.d(&quot;nvm&quot;, &quot;Stopped VibrationService&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to stop VibrationService: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        super.onTaskRemoved(rootIntent)&#10;        // Service continues running even when app is removed from recents&#10;        // START_STICKY in onStartCommand ensures it restarts if killed&#10;        Log.d(&quot;nvm&quot;, &quot;App removed from recents, but service continues running&quot;)&#10;    }&#10;&#10;    @SuppressLint(&quot;ScheduleExactAlarm&quot;)&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        isRunning = false&#10;        handler.removeCallbacks(launchRunnable)&#10;        removeOverlay()&#10;        releaseWakeLock()&#10;        stopVibrationAlert()&#10;&#10;        // Unregister screen state receiver&#10;        try {&#10;            unregisterReceiver(screenStateReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error unregistering receiver: ${e.message}&quot;)&#10;        }&#10;&#10;        // Check if service was enabled by user&#10;        val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;        val wasEnabled = prefs.getBoolean(&quot;service_enabled&quot;, false)&#10;&#10;        if (wasEnabled) {&#10;            Log.d(&quot;nvm&quot;, &quot;Service destroyed but was enabled - scheduling restart&quot;)&#10;&#10;            // Use AlarmManager for reliable restart on Android 13+&#10;            try {&#10;                val alarmManager = getSystemService(ALARM_SERVICE) as AlarmManager&#10;                val restartIntent = Intent(this, ServiceRestartReceiver::class.java).apply {&#10;                    action = &quot;com.akash.fiverrsupport.ACTION_RESTART_SERVICE&quot;&#10;                    putExtra(&quot;interval&quot;, prefs.getLong(&quot;service_interval&quot;, 20000L))&#10;                }&#10;&#10;                val pendingIntent = PendingIntent.getBroadcast(&#10;                    this,&#10;                    0,&#10;                    restartIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;&#10;                // Schedule restart after 2 seconds&#10;                val triggerTime = System.currentTimeMillis() + 2000&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                )&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Restart scheduled via AlarmManager&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;nvm&quot;, &quot;Failed to schedule AlarmManager: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService destroyed&quot;)&#10;    }&#10;&#10;    companion object {&#10;        const val CHANNEL_ID = &quot;FiverrSupportChannel&quot;&#10;        const val NOTIFICATION_ID = 1&#10;        const val ACTION_START = &quot;ACTION_START&quot;&#10;        const val ACTION_STOP = &quot;ACTION_STOP&quot;&#10;        const val ACTION_UPDATE_INTERVAL = &quot;ACTION_UPDATE_INTERVAL&quot;&#10;        const val ACTION_PAUSE_FOR_SLIDER = &quot;ACTION_PAUSE_FOR_SLIDER&quot;&#10;        const val EXTRA_INTERVAL = &quot;EXTRA_INTERVAL&quot;&#10;        const val VIBRATION_CHANNEL_ID = &quot;FiverrSupportVibrationChannel&quot;&#10;        const val VIBRATION_NOTIFICATION_ID = 2&#10;        const val VIBRATION_NOTIFICATION_ID_ALT = 3&#10;    }&#10;}&#10;&#10;/**&#10; * Custom View that displays a beautiful circular countdown timer&#10; */&#10;class CircularTimerView(context: android.content.Context) : View(context) {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var totalDuration = 20000L&#10;    private var startTime = 0L&#10;    private var pausedTime = 0L&#10;    private var isRunning = false&#10;    private var isPaused = false&#10;&#10;    private val backgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#80000000&quot;) // Semi-transparent black&#10;        style = Paint.Style.FILL&#10;    }&#10;&#10;    private val progressPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#4CAF50&quot;) // Green (active)&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 8f&#10;        strokeCap = Paint.Cap.ROUND&#10;    }&#10;&#10;    private val pausedPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#F44336&quot;) // Red (paused)&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 8f&#10;        strokeCap = Paint.Cap.ROUND&#10;    }&#10;&#10;    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.WHITE&#10;        textSize = 24f&#10;        textAlign = Paint.Align.CENTER&#10;        isFakeBoldText = true&#10;    }&#10;&#10;    private val rectF = RectF()&#10;&#10;    private val updateRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; !isPaused) {&#10;                invalidate() // Trigger redraw&#10;                handler.postDelayed(this, 50) // Update every 50ms for smooth animation&#10;            } else if (isPaused) {&#10;                invalidate() // Still redraw to show paused state&#10;                handler.postDelayed(this, 50)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startTimer(duration: Long) {&#10;        totalDuration = duration&#10;        startTime = System.currentTimeMillis()&#10;        isRunning = true&#10;        isPaused = false&#10;        handler.post(updateRunnable)&#10;    }&#10;&#10;    fun stopTimer() {&#10;        isRunning = false&#10;        isPaused = false&#10;        handler.removeCallbacks(updateRunnable)&#10;    }&#10;&#10;    fun setPaused(paused: Boolean) {&#10;        if (paused &amp;&amp; !isPaused) {&#10;            // Entering pause - save current time&#10;            pausedTime = System.currentTimeMillis() - startTime&#10;            isPaused = true&#10;            Log.d(&quot;nvm&quot;, &quot;Timer paused at ${pausedTime}ms&quot;)&#10;        } else if (!paused &amp;&amp; isPaused) {&#10;            // Exiting pause - not used here, use resumeTimer instead&#10;            isPaused = false&#10;        }&#10;        invalidate()&#10;    }&#10;&#10;    fun resetTimer() {&#10;        startTime = System.currentTimeMillis()&#10;        pausedTime = 0L&#10;        isPaused = false&#10;        invalidate()&#10;    }&#10;&#10;    fun resumeTimer() {&#10;        // Resume from where it was paused&#10;        if (isPaused &amp;&amp; pausedTime &gt; 0) {&#10;            startTime = System.currentTimeMillis() - pausedTime&#10;            isPaused = false&#10;            Log.d(&quot;nvm&quot;, &quot;Timer resumed from ${pausedTime}ms (${(totalDuration - pausedTime) / 1000}s remaining)&quot;)&#10;            // Restart the update runnable to continue animation&#10;            handler.post(updateRunnable)&#10;        } else {&#10;            // If not paused or no saved time, just unpause&#10;            isPaused = false&#10;            Log.d(&quot;nvm&quot;, &quot;Timer resumed but no saved pause time - just unpausing&quot;)&#10;        }&#10;        invalidate()&#10;    }&#10;&#10;    fun getPausedTime(): Long {&#10;        return pausedTime&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;&#10;        val width = width.toFloat()&#10;        val height = height.toFloat()&#10;        val centerX = width / 2&#10;        val centerY = height / 2&#10;        val radius = (Math.min(width, height) / 2) - 10&#10;&#10;        // Draw background circle&#10;        canvas.drawCircle(centerX, centerY, radius, backgroundPaint)&#10;&#10;        // Calculate remaining time&#10;        val elapsed = if (isPaused) {&#10;            pausedTime // Use frozen time when paused&#10;        } else {&#10;            System.currentTimeMillis() - startTime&#10;        }&#10;        val remaining = (totalDuration - elapsed).coerceAtLeast(0)&#10;        val progress = (remaining.toFloat() / totalDuration) * 360f&#10;&#10;        // Draw progress arc&#10;        rectF.set(&#10;            centerX - radius + 5,&#10;            centerY - radius + 5,&#10;            centerX + radius - 5,&#10;            centerY + radius - 5&#10;        )&#10;&#10;        // Use red paint if paused, green if active&#10;        val paint = if (isPaused) pausedPaint else progressPaint&#10;        canvas.drawArc(rectF, -90f, progress, false, paint)&#10;&#10;        // Draw remaining time text&#10;        val seconds = (remaining / 1000).toInt()&#10;        val text = &quot;${seconds}s&quot;&#10;        canvas.drawText(text, centerX, centerY + 8, textPaint)&#10;        }&#10;    }&#10;&#10;/**&#10; * Invisible tiny overlay to detect user touches via FLAG_WATCH_OUTSIDE_TOUCH&#10; */&#10;class TouchDetectorView(&#10;    context: Context,&#10;    private val onTouch: () -&gt; Unit&#10;) : View(context) {&#10;&#10;    override fun onTouchEvent(event: MotionEvent?): Boolean {&#10;        // This will be called for outside touches due to FLAG_WATCH_OUTSIDE_TOUCH&#10;        when (event?.action) {&#10;            MotionEvent.ACTION_OUTSIDE -&gt; {&#10;                // User touched outside this tiny 1x1 view (anywhere on screen)&#10;                onTouch()&#10;            }&#10;        }&#10;        return false // Don't consume the touch event - let it pass through&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>