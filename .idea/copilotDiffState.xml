<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/akash/fiverrsupport/FiverrLauncherService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/akash/fiverrsupport/FiverrLauncherService.kt" />
              <option name="originalContent" value="package com.akash.fiverrsupport&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.AlarmManager&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.BroadcastReceiver&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.graphics.Canvas&#10;import android.graphics.Color&#10;import android.graphics.Paint&#10;import android.graphics.PixelFormat&#10;import android.graphics.RectF&#10;import android.os.Build&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.os.PowerManager&#10;import android.os.VibrationEffect&#10;import android.os.VibrationAttributes&#10;import android.os.Vibrator&#10;import android.util.Log&#10;import android.view.Gravity&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.WindowManager&#10;import android.widget.Toast&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;&#10;class FiverrLauncherService : Service() {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var isRunning = false&#10;    private var isPaused = false // New: Track if service is paused due to user interaction&#10;    private var launchInterval = 20000L // Default 20 seconds&#10;    private var lastUserInteractionTime = 0L&#10;    private val idleTimeout = 60000L // 1 minute = 60 seconds&#10;&#10;    // Screen wake-lock components&#10;    private var windowManager: WindowManager? = null&#10;    private var overlayView: CircularTimerView? = null&#10;    private var touchDetectorView: TouchDetectorView? = null&#10;    private var wakeLock: PowerManager.WakeLock? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var isScreenOn = true&#10;    private var isVibrationServiceRunning = false // Track if we intentionally started vibration&#10;&#10;    private var nextLaunchTime = 0L&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        createNotificationChannel()&#10;&#10;        // Initialize vibrator (modern API)&#10;        vibrator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            getSystemService(Vibrator::class.java)&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            getSystemService(VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        // Register screen state receiver&#10;        val filter = IntentFilter().apply {&#10;            addAction(Intent.ACTION_SCREEN_ON)&#10;            addAction(Intent.ACTION_SCREEN_OFF)&#10;        }&#10;        registerReceiver(screenStateReceiver, filter)&#10;&#10;        // Check current screen state&#10;        val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;        isScreenOn = powerManager.isInteractive&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;Service created, screen is ${if (isScreenOn) &quot;ON&quot; else &quot;OFF&quot;}&quot;)&#10;    }&#10;&#10;    // Screen state receiver to detect screen on/off&#10;    private val screenStateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                Intent.ACTION_SCREEN_OFF -&gt; {&#10;                    isScreenOn = false&#10;                    Log.d(&quot;nvm&quot;, &quot;Screen turned OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;                Intent.ACTION_SCREEN_ON -&gt; {&#10;                    isScreenOn = true&#10;&#10;                    // Use a short delay to let keyguard state settle&#10;                    handler.postDelayed({&#10;                        val keyguardManager = getSystemService(KEYGUARD_SERVICE) as android.app.KeyguardManager&#10;                        val isLocked = keyguardManager.isKeyguardLocked&#10;&#10;                        Log.d(&quot;nvm&quot;, &quot;Screen turned ON - isLocked: $isLocked, isVibrationServiceRunning: $isVibrationServiceRunning&quot;)&#10;&#10;                        if (!isLocked &amp;&amp; isVibrationServiceRunning) {&#10;                            // Screen is ON and unlocked - stop vibration&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen unlocked - stopping vibration alert&quot;)&#10;                            stopVibrationAlert()&#10;                        } else if (isLocked) {&#10;                            // Screen on but still locked (wake lock keeping it on for vibration)&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen on but locked - vibration continues&quot;)&#10;                        }&#10;                    }, 500) // 500ms delay to ensure keyguard state is accurate&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private val launchRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; !isPaused) {&#10;                launchFiverrApp()&#10;                nextLaunchTime = System.currentTimeMillis() + launchInterval&#10;            }&#10;            if (isRunning) {&#10;                handler.postDelayed(this, launchInterval)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Check if user has been idle for 1 minute, then auto-resume&#10;    private val idleCheckerRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; isPaused) {&#10;                val idleTime = System.currentTimeMillis() - lastUserInteractionTime&#10;                if (idleTime &gt;= idleTimeout) {&#10;                    Log.d(&quot;nvm&quot;, &quot;User idle for 1 minute - auto-resuming service&quot;)&#10;                    resumeService()&#10;                }&#10;            }&#10;            if (isRunning) {&#10;                handler.postDelayed(this, 1000) // Check every second&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        // Handle null intent when service is restarted by Android after being killed&#10;        if (intent == null) {&#10;            Log.d(&quot;nvm&quot;, &quot;Service restarted by Android (null intent) - restoring from SharedPreferences&quot;)&#10;            val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;            val wasEnabled = prefs.getBoolean(&quot;service_enabled&quot;, false)&#10;            val savedInterval = prefs.getLong(&quot;service_interval&quot;, 20000L)&#10;&#10;            if (wasEnabled) {&#10;                Log.d(&quot;nvm&quot;, &quot;Restoring service with interval: ${savedInterval}ms&quot;)&#10;                launchInterval = savedInterval&#10;                startForegroundServiceInternal()&#10;                isRunning = true&#10;                handler.post(launchRunnable)&#10;                createOverlay()&#10;                acquireWakeLock()&#10;                Log.d(&quot;nvm&quot;, &quot;Service restored successfully&quot;)&#10;&#10;                // Check if screen is off and start vibration if needed&#10;                if (!isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Service restored with screen OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;            } else {&#10;                Log.d(&quot;nvm&quot;, &quot;Service was disabled by user, not restoring&quot;)&#10;                stopSelf()&#10;            }&#10;            return START_STICKY&#10;        }&#10;&#10;        when (intent.action) {&#10;            ACTION_START -&gt; {&#10;                // Get interval from intent, default to 20 seconds&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                // Save service state as enabled - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putBoolean(&quot;service_enabled&quot;, true)&#10;                    .putLong(&quot;service_interval&quot;, launchInterval)&#10;                    .commit() // Use commit() instead of apply() for immediate write&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Saved state: service_enabled=true, interval=${launchInterval}ms&quot;)&#10;&#10;                startForegroundServiceInternal()&#10;                isRunning = true&#10;                handler.post(launchRunnable)&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService started with interval: ${launchInterval}ms&quot;)&#10;&#10;                // Create overlay and acquire wake lock&#10;                createOverlay()&#10;                acquireWakeLock()&#10;&#10;                // Check if screen is off and start vibration if needed&#10;                if (!isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Service started with screen OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;            }&#10;            ACTION_STOP -&gt; {&#10;                isRunning = false&#10;                handler.removeCallbacks(launchRunnable)&#10;&#10;                // Save service state as disabled - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putBoolean(&quot;service_enabled&quot;, false)&#10;                    .commit() // Use commit() instead of apply()&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Saved state: service_enabled=false&quot;)&#10;&#10;                // Stop vibration, remove overlay and release wake lock&#10;                stopVibrationAlert()&#10;                removeOverlay()&#10;                releaseWakeLock()&#10;&#10;                stopForegroundServiceInternal()&#10;                Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService stopped&quot;)&#10;            }&#10;            ACTION_UPDATE_INTERVAL -&gt; {&#10;                // Update interval without restarting service&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                // Save updated interval - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putLong(&quot;service_interval&quot;, launchInterval)&#10;                    .commit()&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Interval updated to: ${launchInterval}ms&quot;)&#10;                // Cancel current scheduled task and reschedule with new interval&#10;                handler.removeCallbacks(launchRunnable)&#10;                if (isRunning) {&#10;                    // Restart timer with new interval&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    handler.post(launchRunnable)&#10;                }&#10;            }&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun createOverlay() {&#10;        try {&#10;            windowManager = getSystemService(WINDOW_SERVICE) as WindowManager&#10;&#10;            val layoutType = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#10;            }&#10;&#10;            // Create touch detector overlay (full screen, invisible)&#10;            touchDetectorView = TouchDetectorView(this) { userTouched() }&#10;            val touchParams = WindowManager.LayoutParams(&#10;                1, // Very small, just 1 pixel&#10;                1, // Very small, just 1 pixel&#10;                layoutType,&#10;                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or&#10;                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or&#10;                        WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH or&#10;                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,&#10;                PixelFormat.TRANSLUCENT&#10;            ).apply {&#10;                gravity = Gravity.TOP or Gravity.START&#10;                x = 0&#10;                y = 0&#10;            }&#10;            windowManager?.addView(touchDetectorView, touchParams)&#10;            Log.d(&quot;nvm&quot;, &quot;Touch detector overlay created&quot;)&#10;&#10;            // Create circular timer overlay&#10;            overlayView = CircularTimerView(this)&#10;            val overlaySize = 120 // 120dp for circular timer&#10;            val params = WindowManager.LayoutParams(&#10;                overlaySize,&#10;                overlaySize,&#10;                layoutType,&#10;                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or&#10;                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or&#10;                        WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or&#10;                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,&#10;                PixelFormat.TRANSLUCENT&#10;            ).apply {&#10;                gravity = Gravity.TOP or Gravity.END&#10;                x = 20 // 20px from right edge&#10;                y = 100 // 100px from top&#10;            }&#10;&#10;            windowManager?.addView(overlayView, params)&#10;            overlayView?.startTimer(launchInterval)&#10;            Log.d(&quot;nvm&quot;, &quot;Circular timer overlay created&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error creating overlay: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun removeOverlay() {&#10;        try {&#10;            if (touchDetectorView != null) {&#10;                windowManager?.removeView(touchDetectorView)&#10;                touchDetectorView = null&#10;            }&#10;            if (overlayView != null) {&#10;                overlayView?.stopTimer()&#10;                windowManager?.removeView(overlayView)&#10;                overlayView = null&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error removing overlay: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun acquireWakeLock() {&#10;        try {&#10;            val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;            wakeLock = powerManager.newWakeLock(&#10;                PowerManager.SCREEN_DIM_WAKE_LOCK,&#10;                &quot;FiverrSupport:KeepScreenOnWakeLock&quot;&#10;            )&#10;            wakeLock?.acquire(10 * 60 * 60 * 1000L) // 10 hour timeout&#10;            Log.d(&quot;nvm&quot;, &quot;WakeLock acquired&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error acquiring wake lock: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun releaseWakeLock() {&#10;        try {&#10;            wakeLock?.release()&#10;            wakeLock = null&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error releasing wake lock: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun startForegroundServiceInternal() {&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;        Toast.makeText(this, &quot;Fiverr Support Service Started&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun stopForegroundServiceInternal() {&#10;        stopForeground(STOP_FOREGROUND_REMOVE)&#10;        stopSelf()&#10;        Toast.makeText(this, &quot;Fiverr Support Service Stopped&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun createNotification(): Notification {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, notificationIntent,&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Fiverr Support&quot;)&#10;            .setContentText(&quot;Service running - keeping screen awake &amp; opening Fiverr&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .build()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Fiverr Support Service&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Shows when Fiverr support service is running&quot;&#10;            }&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun launchFiverrApp() {&#10;        try {&#10;            val intent = packageManager.getLaunchIntentForPackage(&quot;com.fiverr.fiverr&quot;)&#10;            if (intent != null) {&#10;                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)&#10;                startActivity(intent)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;Fiverr app package not found&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error launching Fiverr app: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Called when user touches the screen&#10;    private fun userTouched() {&#10;        lastUserInteractionTime = System.currentTimeMillis()&#10;&#10;        if (!isPaused) {&#10;            pauseService()&#10;        }&#10;    }&#10;&#10;    // Pause the service (stop opening Fiverr, turn timer red)&#10;    private fun pauseService() {&#10;        isPaused = true&#10;        overlayView?.setPaused(true) // Turn timer red&#10;        handler.post(idleCheckerRunnable) // Start idle checker&#10;        Log.d(&quot;nvm&quot;, &quot;Service paused due to user interaction&quot;)&#10;    }&#10;&#10;    // Resume the service (start opening Fiverr, turn timer green)&#10;    private fun resumeService() {&#10;        isPaused = false&#10;        overlayView?.setPaused(false) // Turn timer green&#10;        overlayView?.resetTimer() // Reset timer to start fresh&#10;        handler.removeCallbacks(idleCheckerRunnable) // Stop idle checker&#10;        Log.d(&quot;nvm&quot;, &quot;Service resumed&quot;)&#10;    }&#10;&#10;    // Helper to start both vibration engines&#10;    private fun startVibrationAlert() {&#10;        try {&#10;            Log.d(&quot;nvm&quot;, &quot;startVibrationAlert() called - isRunning: $isRunning, isScreenOn: $isScreenOn&quot;)&#10;            if (isRunning) {&#10;                isVibrationServiceRunning = true // Set flag BEFORE starting service&#10;                val serviceIntent = Intent(this, VibrationService::class.java)&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    startForegroundService(serviceIntent)&#10;                } else {&#10;                    startService(serviceIntent)&#10;                }&#10;                Log.d(&quot;nvm&quot;, &quot;Started VibrationService via ${if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &quot;startForegroundService&quot; else &quot;startService&quot;}&quot;)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;Cannot start VibrationService - isRunning is false&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to start VibrationService: ${e.message}&quot;, e)&#10;            isVibrationServiceRunning = false&#10;        }&#10;    }&#10;&#10;    // Helper to stop both vibration engines&#10;    private fun stopVibrationAlert() {&#10;        try {&#10;            isVibrationServiceRunning = false // Clear flag BEFORE stopping service&#10;            stopService(Intent(this, VibrationService::class.java))&#10;            Log.d(&quot;nvm&quot;, &quot;Stopped VibrationService&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to stop VibrationService: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        super.onTaskRemoved(rootIntent)&#10;        // Service continues running even when app is removed from recents&#10;        // START_STICKY in onStartCommand ensures it restarts if killed&#10;        Log.d(&quot;nvm&quot;, &quot;App removed from recents, but service continues running&quot;)&#10;    }&#10;&#10;    @SuppressLint(&quot;ScheduleExactAlarm&quot;)&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        isRunning = false&#10;        handler.removeCallbacks(launchRunnable)&#10;        removeOverlay()&#10;        releaseWakeLock()&#10;        stopVibrationAlert()&#10;&#10;        // Unregister screen state receiver&#10;        try {&#10;            unregisterReceiver(screenStateReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error unregistering receiver: ${e.message}&quot;)&#10;        }&#10;&#10;        // Check if service was enabled by user&#10;        val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;        val wasEnabled = prefs.getBoolean(&quot;service_enabled&quot;, false)&#10;&#10;        if (wasEnabled) {&#10;            Log.d(&quot;nvm&quot;, &quot;Service destroyed but was enabled - scheduling restart&quot;)&#10;&#10;            // Use AlarmManager for reliable restart on Android 13+&#10;            try {&#10;                val alarmManager = getSystemService(ALARM_SERVICE) as AlarmManager&#10;                val restartIntent = Intent(this, ServiceRestartReceiver::class.java).apply {&#10;                    action = &quot;com.akash.fiverrsupport.ACTION_RESTART_SERVICE&quot;&#10;                    putExtra(&quot;interval&quot;, prefs.getLong(&quot;service_interval&quot;, 20000L))&#10;                }&#10;&#10;                val pendingIntent = PendingIntent.getBroadcast(&#10;                    this,&#10;                    0,&#10;                    restartIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;&#10;                // Schedule restart after 2 seconds&#10;                val triggerTime = System.currentTimeMillis() + 2000&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                )&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Restart scheduled via AlarmManager&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;nvm&quot;, &quot;Failed to schedule AlarmManager: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService destroyed&quot;)&#10;    }&#10;&#10;    companion object {&#10;        const val CHANNEL_ID = &quot;FiverrSupportChannel&quot;&#10;        const val NOTIFICATION_ID = 1&#10;        const val ACTION_START = &quot;ACTION_START&quot;&#10;        const val ACTION_STOP = &quot;ACTION_STOP&quot;&#10;        const val ACTION_UPDATE_INTERVAL = &quot;ACTION_UPDATE_INTERVAL&quot;&#10;        const val EXTRA_INTERVAL = &quot;EXTRA_INTERVAL&quot;&#10;        const val VIBRATION_CHANNEL_ID = &quot;FiverrSupportVibrationChannel&quot;&#10;        const val VIBRATION_NOTIFICATION_ID = 2&#10;        const val VIBRATION_NOTIFICATION_ID_ALT = 3&#10;    }&#10;}&#10;&#10;/**&#10; * Custom View that displays a beautiful circular countdown timer&#10; */&#10;class CircularTimerView(context: android.content.Context) : View(context) {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var totalDuration = 20000L&#10;    private var startTime = 0L&#10;    private var pausedTime = 0L&#10;    private var isRunning = false&#10;    private var isPaused = false&#10;&#10;    private val backgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#80000000&quot;) // Semi-transparent black&#10;        style = Paint.Style.FILL&#10;    }&#10;&#10;    private val progressPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#4CAF50&quot;) // Green (active)&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 8f&#10;        strokeCap = Paint.Cap.ROUND&#10;    }&#10;&#10;    private val pausedPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#F44336&quot;) // Red (paused)&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 8f&#10;        strokeCap = Paint.Cap.ROUND&#10;    }&#10;&#10;    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.WHITE&#10;        textSize = 24f&#10;        textAlign = Paint.Align.CENTER&#10;        isFakeBoldText = true&#10;    }&#10;&#10;    private val rectF = RectF()&#10;&#10;    private val updateRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; !isPaused) {&#10;                invalidate() // Trigger redraw&#10;                handler.postDelayed(this, 50) // Update every 50ms for smooth animation&#10;            } else if (isPaused) {&#10;                invalidate() // Still redraw to show paused state&#10;                handler.postDelayed(this, 50)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startTimer(duration: Long) {&#10;        totalDuration = duration&#10;        startTime = System.currentTimeMillis()&#10;        isRunning = true&#10;        isPaused = false&#10;        handler.post(updateRunnable)&#10;    }&#10;&#10;    fun stopTimer() {&#10;        isRunning = false&#10;        isPaused = false&#10;        handler.removeCallbacks(updateRunnable)&#10;    }&#10;&#10;    fun setPaused(paused: Boolean) {&#10;        if (paused &amp;&amp; !isPaused) {&#10;            // Entering pause - save current time&#10;            pausedTime = System.currentTimeMillis() - startTime&#10;            isPaused = true&#10;            Log.d(&quot;nvm&quot;, &quot;Timer paused at ${pausedTime}ms&quot;)&#10;        } else if (!paused &amp;&amp; isPaused) {&#10;            // Exiting pause - not used here, use resetTimer instead&#10;            isPaused = false&#10;        }&#10;        invalidate()&#10;    }&#10;&#10;    fun resetTimer() {&#10;        startTime = System.currentTimeMillis()&#10;        pausedTime = 0L&#10;        isPaused = false&#10;        invalidate()&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;&#10;        val width = width.toFloat()&#10;        val height = height.toFloat()&#10;        val centerX = width / 2&#10;        val centerY = height / 2&#10;        val radius = (Math.min(width, height) / 2) - 10&#10;&#10;        // Draw background circle&#10;        canvas.drawCircle(centerX, centerY, radius, backgroundPaint)&#10;&#10;        // Calculate remaining time&#10;        val elapsed = if (isPaused) {&#10;            pausedTime // Use frozen time when paused&#10;        } else {&#10;            System.currentTimeMillis() - startTime&#10;        }&#10;        val remaining = (totalDuration - elapsed).coerceAtLeast(0)&#10;        val progress = (remaining.toFloat() / totalDuration) * 360f&#10;&#10;        // Draw progress arc&#10;        rectF.set(&#10;            centerX - radius + 5,&#10;            centerY - radius + 5,&#10;            centerX + radius - 5,&#10;            centerY + radius - 5&#10;        )&#10;&#10;        // Use red paint if paused, green if active&#10;        val paint = if (isPaused) pausedPaint else progressPaint&#10;        canvas.drawArc(rectF, -90f, progress, false, paint)&#10;&#10;        // Draw remaining time text&#10;        val seconds = (remaining / 1000).toInt()&#10;        val text = if (isPaused) &quot;â¸ ${seconds}s&quot; else &quot;${seconds}s&quot;&#10;        canvas.drawText(text, centerX, centerY + 8, textPaint)&#10;&#10;        // Reset timer when it reaches 0 (only if not paused)&#10;        if (remaining &lt;= 0 &amp;&amp; !isPaused) {&#10;            startTime = System.currentTimeMillis()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Invisible tiny overlay to detect user touches via FLAG_WATCH_OUTSIDE_TOUCH&#10; */&#10;class TouchDetectorView(&#10;    context: Context,&#10;    private val onTouch: () -&gt; Unit&#10;) : View(context) {&#10;&#10;    override fun onTouchEvent(event: MotionEvent?): Boolean {&#10;        // This will be called for outside touches due to FLAG_WATCH_OUTSIDE_TOUCH&#10;        when (event?.action) {&#10;            MotionEvent.ACTION_OUTSIDE -&gt; {&#10;                // User touched outside this tiny 1x1 view (anywhere on screen)&#10;                onTouch()&#10;            }&#10;        }&#10;        return false // Don't consume the touch event - let it pass through&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.akash.fiverrsupport&#10;&#10;import android.annotation.SuppressLint&#10;import android.app.AlarmManager&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.BroadcastReceiver&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.IntentFilter&#10;import android.graphics.Canvas&#10;import android.graphics.Color&#10;import android.graphics.Paint&#10;import android.graphics.PixelFormat&#10;import android.graphics.RectF&#10;import android.os.Build&#10;import android.os.Handler&#10;import android.os.IBinder&#10;import android.os.Looper&#10;import android.os.PowerManager&#10;import android.os.VibrationEffect&#10;import android.os.VibrationAttributes&#10;import android.os.Vibrator&#10;import android.util.Log&#10;import android.view.Gravity&#10;import android.view.MotionEvent&#10;import android.view.View&#10;import android.view.WindowManager&#10;import android.widget.Toast&#10;import androidx.core.app.NotificationCompat&#10;import androidx.core.app.NotificationManagerCompat&#10;&#10;class FiverrLauncherService : Service() {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var isRunning = false&#10;    private var isPaused = false // New: Track if service is paused due to user interaction&#10;    private var launchInterval = 20000L // Default 20 seconds&#10;    private var lastUserInteractionTime = 0L&#10;    private val idleTimeout = 60000L // 1 minute = 60 seconds&#10;&#10;    // Screen wake-lock components&#10;    private var windowManager: WindowManager? = null&#10;    private var overlayView: CircularTimerView? = null&#10;    private var touchDetectorView: TouchDetectorView? = null&#10;    private var wakeLock: PowerManager.WakeLock? = null&#10;    private var vibrator: Vibrator? = null&#10;    private var isScreenOn = true&#10;    private var isVibrationServiceRunning = false // Track if we intentionally started vibration&#10;&#10;    private var nextLaunchTime = 0L&#10;&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        createNotificationChannel()&#10;&#10;        // Initialize vibrator (modern API)&#10;        vibrator = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {&#10;            getSystemService(Vibrator::class.java)&#10;        } else {&#10;            @Suppress(&quot;DEPRECATION&quot;)&#10;            getSystemService(VIBRATOR_SERVICE) as Vibrator&#10;        }&#10;&#10;        // Register screen state receiver&#10;        val filter = IntentFilter().apply {&#10;            addAction(Intent.ACTION_SCREEN_ON)&#10;            addAction(Intent.ACTION_SCREEN_OFF)&#10;            addAction(Intent.ACTION_USER_PRESENT) // Fires when user unlocks device&#10;        }&#10;        registerReceiver(screenStateReceiver, filter)&#10;&#10;        // Check current screen state&#10;        val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;        isScreenOn = powerManager.isInteractive&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;Service created, screen is ${if (isScreenOn) &quot;ON&quot; else &quot;OFF&quot;}&quot;)&#10;    }&#10;&#10;    // Screen state receiver to detect screen on/off&#10;    private val screenStateReceiver = object : BroadcastReceiver() {&#10;        override fun onReceive(context: Context?, intent: Intent?) {&#10;            when (intent?.action) {&#10;                Intent.ACTION_SCREEN_OFF -&gt; {&#10;                    isScreenOn = false&#10;                    Log.d(&quot;nvm&quot;, &quot;Screen turned OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;                Intent.ACTION_SCREEN_ON -&gt; {&#10;                    isScreenOn = true&#10;&#10;                    // Use a short delay to let keyguard state settle&#10;                    handler.postDelayed({&#10;                        val keyguardManager = getSystemService(KEYGUARD_SERVICE) as android.app.KeyguardManager&#10;                        val isLocked = keyguardManager.isKeyguardLocked&#10;&#10;                        Log.d(&quot;nvm&quot;, &quot;Screen turned ON - isLocked: $isLocked, isVibrationServiceRunning: $isVibrationServiceRunning&quot;)&#10;&#10;                        if (!isLocked &amp;&amp; isVibrationServiceRunning) {&#10;                            // Screen is ON and unlocked - stop vibration&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen unlocked - stopping vibration alert&quot;)&#10;                            stopVibrationAlert()&#10;                        } else if (isLocked) {&#10;                            // Screen on but still locked (wake lock keeping it on for vibration)&#10;                            Log.d(&quot;nvm&quot;, &quot;Screen on but locked - vibration continues&quot;)&#10;                        }&#10;                    }, 500) // 500ms delay to ensure keyguard state is accurate&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private val launchRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; !isPaused) {&#10;                launchFiverrApp()&#10;                nextLaunchTime = System.currentTimeMillis() + launchInterval&#10;            }&#10;            if (isRunning) {&#10;                handler.postDelayed(this, launchInterval)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Check if user has been idle for 1 minute, then auto-resume&#10;    private val idleCheckerRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; isPaused) {&#10;                val idleTime = System.currentTimeMillis() - lastUserInteractionTime&#10;                if (idleTime &gt;= idleTimeout) {&#10;                    Log.d(&quot;nvm&quot;, &quot;User idle for 1 minute - auto-resuming service&quot;)&#10;                    resumeService()&#10;                }&#10;            }&#10;            if (isRunning) {&#10;                handler.postDelayed(this, 1000) // Check every second&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        // Handle null intent when service is restarted by Android after being killed&#10;        if (intent == null) {&#10;            Log.d(&quot;nvm&quot;, &quot;Service restarted by Android (null intent) - restoring from SharedPreferences&quot;)&#10;            val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;            val wasEnabled = prefs.getBoolean(&quot;service_enabled&quot;, false)&#10;            val savedInterval = prefs.getLong(&quot;service_interval&quot;, 20000L)&#10;&#10;            if (wasEnabled) {&#10;                Log.d(&quot;nvm&quot;, &quot;Restoring service with interval: ${savedInterval}ms&quot;)&#10;                launchInterval = savedInterval&#10;                startForegroundServiceInternal()&#10;                isRunning = true&#10;                handler.post(launchRunnable)&#10;                createOverlay()&#10;                acquireWakeLock()&#10;                Log.d(&quot;nvm&quot;, &quot;Service restored successfully&quot;)&#10;&#10;                // Check if screen is off and start vibration if needed&#10;                if (!isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Service restored with screen OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;            } else {&#10;                Log.d(&quot;nvm&quot;, &quot;Service was disabled by user, not restoring&quot;)&#10;                stopSelf()&#10;            }&#10;            return START_STICKY&#10;        }&#10;&#10;        when (intent.action) {&#10;            ACTION_START -&gt; {&#10;                // Get interval from intent, default to 20 seconds&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                // Save service state as enabled - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putBoolean(&quot;service_enabled&quot;, true)&#10;                    .putLong(&quot;service_interval&quot;, launchInterval)&#10;                    .commit() // Use commit() instead of apply() for immediate write&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Saved state: service_enabled=true, interval=${launchInterval}ms&quot;)&#10;&#10;                startForegroundServiceInternal()&#10;                isRunning = true&#10;                handler.post(launchRunnable)&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService started with interval: ${launchInterval}ms&quot;)&#10;&#10;                // Create overlay and acquire wake lock&#10;                createOverlay()&#10;                acquireWakeLock()&#10;&#10;                // Check if screen is off and start vibration if needed&#10;                if (!isScreenOn) {&#10;                    Log.d(&quot;nvm&quot;, &quot;Service started with screen OFF - starting vibration alert&quot;)&#10;                    startVibrationAlert()&#10;                }&#10;            }&#10;            ACTION_STOP -&gt; {&#10;                isRunning = false&#10;                handler.removeCallbacks(launchRunnable)&#10;&#10;                // Save service state as disabled - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putBoolean(&quot;service_enabled&quot;, false)&#10;                    .commit() // Use commit() instead of apply()&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Saved state: service_enabled=false&quot;)&#10;&#10;                // Stop vibration, remove overlay and release wake lock&#10;                stopVibrationAlert()&#10;                removeOverlay()&#10;                releaseWakeLock()&#10;&#10;                stopForegroundServiceInternal()&#10;                Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService stopped&quot;)&#10;            }&#10;            ACTION_UPDATE_INTERVAL -&gt; {&#10;                // Update interval without restarting service&#10;                launchInterval = intent.getLongExtra(EXTRA_INTERVAL, 20000L)&#10;&#10;                // Save updated interval - use commit() for immediate write&#10;                val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;                prefs.edit()&#10;                    .putLong(&quot;service_interval&quot;, launchInterval)&#10;                    .commit()&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Interval updated to: ${launchInterval}ms&quot;)&#10;                // Cancel current scheduled task and reschedule with new interval&#10;                handler.removeCallbacks(launchRunnable)&#10;                if (isRunning) {&#10;                    // Restart timer with new interval&#10;                    overlayView?.stopTimer()&#10;                    overlayView?.startTimer(launchInterval)&#10;                    handler.post(launchRunnable)&#10;                }&#10;            }&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    private fun createOverlay() {&#10;        try {&#10;            windowManager = getSystemService(WINDOW_SERVICE) as WindowManager&#10;&#10;            val layoutType = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                WindowManager.LayoutParams.TYPE_APPLICATION_OVERLAY&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                WindowManager.LayoutParams.TYPE_SYSTEM_ALERT&#10;            }&#10;&#10;            // Create touch detector overlay (full screen, invisible)&#10;            touchDetectorView = TouchDetectorView(this) { userTouched() }&#10;            val touchParams = WindowManager.LayoutParams(&#10;                1, // Very small, just 1 pixel&#10;                1, // Very small, just 1 pixel&#10;                layoutType,&#10;                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or&#10;                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or&#10;                        WindowManager.LayoutParams.FLAG_WATCH_OUTSIDE_TOUCH or&#10;                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,&#10;                PixelFormat.TRANSLUCENT&#10;            ).apply {&#10;                gravity = Gravity.TOP or Gravity.START&#10;                x = 0&#10;                y = 0&#10;            }&#10;            windowManager?.addView(touchDetectorView, touchParams)&#10;            Log.d(&quot;nvm&quot;, &quot;Touch detector overlay created&quot;)&#10;&#10;            // Create circular timer overlay&#10;            overlayView = CircularTimerView(this)&#10;            val overlaySize = 120 // 120dp for circular timer&#10;            val params = WindowManager.LayoutParams(&#10;                overlaySize,&#10;                overlaySize,&#10;                layoutType,&#10;                WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE or&#10;                        WindowManager.LayoutParams.FLAG_NOT_TOUCHABLE or&#10;                        WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS or&#10;                        WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON,&#10;                PixelFormat.TRANSLUCENT&#10;            ).apply {&#10;                gravity = Gravity.TOP or Gravity.END&#10;                x = 20 // 20px from right edge&#10;                y = 100 // 100px from top&#10;            }&#10;&#10;            windowManager?.addView(overlayView, params)&#10;            overlayView?.startTimer(launchInterval)&#10;            Log.d(&quot;nvm&quot;, &quot;Circular timer overlay created&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error creating overlay: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun removeOverlay() {&#10;        try {&#10;            if (touchDetectorView != null) {&#10;                windowManager?.removeView(touchDetectorView)&#10;                touchDetectorView = null&#10;            }&#10;            if (overlayView != null) {&#10;                overlayView?.stopTimer()&#10;                windowManager?.removeView(overlayView)&#10;                overlayView = null&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error removing overlay: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun acquireWakeLock() {&#10;        try {&#10;            val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;            wakeLock = powerManager.newWakeLock(&#10;                PowerManager.SCREEN_DIM_WAKE_LOCK,&#10;                &quot;FiverrSupport:KeepScreenOnWakeLock&quot;&#10;            )&#10;            wakeLock?.acquire(10 * 60 * 60 * 1000L) // 10 hour timeout&#10;            Log.d(&quot;nvm&quot;, &quot;WakeLock acquired&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error acquiring wake lock: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    private fun releaseWakeLock() {&#10;        try {&#10;            wakeLock?.release()&#10;            wakeLock = null&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error releasing wake lock: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    private fun startForegroundServiceInternal() {&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;        Toast.makeText(this, &quot;Fiverr Support Service Started&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun stopForegroundServiceInternal() {&#10;        stopForeground(STOP_FOREGROUND_REMOVE)&#10;        stopSelf()&#10;        Toast.makeText(this, &quot;Fiverr Support Service Stopped&quot;, Toast.LENGTH_SHORT).show()&#10;    }&#10;&#10;    private fun createNotification(): Notification {&#10;        val notificationIntent = Intent(this, MainActivity::class.java)&#10;        val pendingIntent = PendingIntent.getActivity(&#10;            this, 0, notificationIntent,&#10;            PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;&#10;        return NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(&quot;Fiverr Support&quot;)&#10;            .setContentText(&quot;Service running - keeping screen awake &amp; opening Fiverr&quot;)&#10;            .setSmallIcon(android.R.drawable.ic_dialog_info)&#10;            .setContentIntent(pendingIntent)&#10;            .setOngoing(true)&#10;            .build()&#10;    }&#10;&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                &quot;Fiverr Support Service&quot;,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = &quot;Shows when Fiverr support service is running&quot;&#10;            }&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;&#10;    private fun launchFiverrApp() {&#10;        try {&#10;            val intent = packageManager.getLaunchIntentForPackage(&quot;com.fiverr.fiverr&quot;)&#10;            if (intent != null) {&#10;                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)&#10;                startActivity(intent)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;Fiverr app package not found&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error launching Fiverr app: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    // Called when user touches the screen&#10;    private fun userTouched() {&#10;        lastUserInteractionTime = System.currentTimeMillis()&#10;&#10;        if (!isPaused) {&#10;            pauseService()&#10;        }&#10;    }&#10;&#10;    // Pause the service (stop opening Fiverr, turn timer red)&#10;    private fun pauseService() {&#10;        isPaused = true&#10;        overlayView?.setPaused(true) // Turn timer red&#10;        handler.post(idleCheckerRunnable) // Start idle checker&#10;        Log.d(&quot;nvm&quot;, &quot;Service paused due to user interaction&quot;)&#10;    }&#10;&#10;    // Resume the service (start opening Fiverr, turn timer green)&#10;    private fun resumeService() {&#10;        isPaused = false&#10;        overlayView?.setPaused(false) // Turn timer green&#10;        overlayView?.resetTimer() // Reset timer to start fresh&#10;        handler.removeCallbacks(idleCheckerRunnable) // Stop idle checker&#10;        Log.d(&quot;nvm&quot;, &quot;Service resumed&quot;)&#10;    }&#10;&#10;    // Helper to start both vibration engines&#10;    private fun startVibrationAlert() {&#10;        try {&#10;            Log.d(&quot;nvm&quot;, &quot;startVibrationAlert() called - isRunning: $isRunning, isScreenOn: $isScreenOn&quot;)&#10;            if (isRunning) {&#10;                isVibrationServiceRunning = true // Set flag BEFORE starting service&#10;                val serviceIntent = Intent(this, VibrationService::class.java)&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;                    startForegroundService(serviceIntent)&#10;                } else {&#10;                    startService(serviceIntent)&#10;                }&#10;                Log.d(&quot;nvm&quot;, &quot;Started VibrationService via ${if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &quot;startForegroundService&quot; else &quot;startService&quot;}&quot;)&#10;            } else {&#10;                Log.w(&quot;nvm&quot;, &quot;Cannot start VibrationService - isRunning is false&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to start VibrationService: ${e.message}&quot;, e)&#10;            isVibrationServiceRunning = false&#10;        }&#10;    }&#10;&#10;    // Helper to stop both vibration engines&#10;    private fun stopVibrationAlert() {&#10;        try {&#10;            isVibrationServiceRunning = false // Clear flag BEFORE stopping service&#10;            stopService(Intent(this, VibrationService::class.java))&#10;            Log.d(&quot;nvm&quot;, &quot;Stopped VibrationService&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Failed to stop VibrationService: ${e.message}&quot;)&#10;        }&#10;    }&#10;&#10;    override fun onBind(intent: Intent?): IBinder? = null&#10;&#10;    override fun onTaskRemoved(rootIntent: Intent?) {&#10;        super.onTaskRemoved(rootIntent)&#10;        // Service continues running even when app is removed from recents&#10;        // START_STICKY in onStartCommand ensures it restarts if killed&#10;        Log.d(&quot;nvm&quot;, &quot;App removed from recents, but service continues running&quot;)&#10;    }&#10;&#10;    @SuppressLint(&quot;ScheduleExactAlarm&quot;)&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        isRunning = false&#10;        handler.removeCallbacks(launchRunnable)&#10;        removeOverlay()&#10;        releaseWakeLock()&#10;        stopVibrationAlert()&#10;&#10;        // Unregister screen state receiver&#10;        try {&#10;            unregisterReceiver(screenStateReceiver)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;nvm&quot;, &quot;Error unregistering receiver: ${e.message}&quot;)&#10;        }&#10;&#10;        // Check if service was enabled by user&#10;        val prefs = getSharedPreferences(&quot;FiverrSupportPrefs&quot;, MODE_PRIVATE)&#10;        val wasEnabled = prefs.getBoolean(&quot;service_enabled&quot;, false)&#10;&#10;        if (wasEnabled) {&#10;            Log.d(&quot;nvm&quot;, &quot;Service destroyed but was enabled - scheduling restart&quot;)&#10;&#10;            // Use AlarmManager for reliable restart on Android 13+&#10;            try {&#10;                val alarmManager = getSystemService(ALARM_SERVICE) as AlarmManager&#10;                val restartIntent = Intent(this, ServiceRestartReceiver::class.java).apply {&#10;                    action = &quot;com.akash.fiverrsupport.ACTION_RESTART_SERVICE&quot;&#10;                    putExtra(&quot;interval&quot;, prefs.getLong(&quot;service_interval&quot;, 20000L))&#10;                }&#10;&#10;                val pendingIntent = PendingIntent.getBroadcast(&#10;                    this,&#10;                    0,&#10;                    restartIntent,&#10;                    PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;                )&#10;&#10;                // Schedule restart after 2 seconds&#10;                val triggerTime = System.currentTimeMillis() + 2000&#10;                alarmManager.setExact(&#10;                    AlarmManager.RTC_WAKEUP,&#10;                    triggerTime,&#10;                    pendingIntent&#10;                )&#10;&#10;                Log.d(&quot;nvm&quot;, &quot;Restart scheduled via AlarmManager&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;nvm&quot;, &quot;Failed to schedule AlarmManager: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        Log.d(&quot;nvm&quot;, &quot;FiverrLauncherService destroyed&quot;)&#10;    }&#10;&#10;    companion object {&#10;        const val CHANNEL_ID = &quot;FiverrSupportChannel&quot;&#10;        const val NOTIFICATION_ID = 1&#10;        const val ACTION_START = &quot;ACTION_START&quot;&#10;        const val ACTION_STOP = &quot;ACTION_STOP&quot;&#10;        const val ACTION_UPDATE_INTERVAL = &quot;ACTION_UPDATE_INTERVAL&quot;&#10;        const val EXTRA_INTERVAL = &quot;EXTRA_INTERVAL&quot;&#10;        const val VIBRATION_CHANNEL_ID = &quot;FiverrSupportVibrationChannel&quot;&#10;        const val VIBRATION_NOTIFICATION_ID = 2&#10;        const val VIBRATION_NOTIFICATION_ID_ALT = 3&#10;    }&#10;}&#10;&#10;/**&#10; * Custom View that displays a beautiful circular countdown timer&#10; */&#10;class CircularTimerView(context: android.content.Context) : View(context) {&#10;&#10;    private val handler = Handler(Looper.getMainLooper())&#10;    private var totalDuration = 20000L&#10;    private var startTime = 0L&#10;    private var pausedTime = 0L&#10;    private var isRunning = false&#10;    private var isPaused = false&#10;&#10;    private val backgroundPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#80000000&quot;) // Semi-transparent black&#10;        style = Paint.Style.FILL&#10;    }&#10;&#10;    private val progressPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#4CAF50&quot;) // Green (active)&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 8f&#10;        strokeCap = Paint.Cap.ROUND&#10;    }&#10;&#10;    private val pausedPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.parseColor(&quot;#F44336&quot;) // Red (paused)&#10;        style = Paint.Style.STROKE&#10;        strokeWidth = 8f&#10;        strokeCap = Paint.Cap.ROUND&#10;    }&#10;&#10;    private val textPaint = Paint(Paint.ANTI_ALIAS_FLAG).apply {&#10;        color = Color.WHITE&#10;        textSize = 24f&#10;        textAlign = Paint.Align.CENTER&#10;        isFakeBoldText = true&#10;    }&#10;&#10;    private val rectF = RectF()&#10;&#10;    private val updateRunnable = object : Runnable {&#10;        override fun run() {&#10;            if (isRunning &amp;&amp; !isPaused) {&#10;                invalidate() // Trigger redraw&#10;                handler.postDelayed(this, 50) // Update every 50ms for smooth animation&#10;            } else if (isPaused) {&#10;                invalidate() // Still redraw to show paused state&#10;                handler.postDelayed(this, 50)&#10;            }&#10;        }&#10;    }&#10;&#10;    fun startTimer(duration: Long) {&#10;        totalDuration = duration&#10;        startTime = System.currentTimeMillis()&#10;        isRunning = true&#10;        isPaused = false&#10;        handler.post(updateRunnable)&#10;    }&#10;&#10;    fun stopTimer() {&#10;        isRunning = false&#10;        isPaused = false&#10;        handler.removeCallbacks(updateRunnable)&#10;    }&#10;&#10;    fun setPaused(paused: Boolean) {&#10;        if (paused &amp;&amp; !isPaused) {&#10;            // Entering pause - save current time&#10;            pausedTime = System.currentTimeMillis() - startTime&#10;            isPaused = true&#10;            Log.d(&quot;nvm&quot;, &quot;Timer paused at ${pausedTime}ms&quot;)&#10;        } else if (!paused &amp;&amp; isPaused) {&#10;            // Exiting pause - not used here, use resetTimer instead&#10;            isPaused = false&#10;        }&#10;        invalidate()&#10;    }&#10;&#10;    fun resetTimer() {&#10;        startTime = System.currentTimeMillis()&#10;        pausedTime = 0L&#10;        isPaused = false&#10;        invalidate()&#10;    }&#10;&#10;    override fun onDraw(canvas: Canvas) {&#10;        super.onDraw(canvas)&#10;&#10;        val width = width.toFloat()&#10;        val height = height.toFloat()&#10;        val centerX = width / 2&#10;        val centerY = height / 2&#10;        val radius = (Math.min(width, height) / 2) - 10&#10;&#10;        // Draw background circle&#10;        canvas.drawCircle(centerX, centerY, radius, backgroundPaint)&#10;&#10;        // Calculate remaining time&#10;        val elapsed = if (isPaused) {&#10;            pausedTime // Use frozen time when paused&#10;        } else {&#10;            System.currentTimeMillis() - startTime&#10;        }&#10;        val remaining = (totalDuration - elapsed).coerceAtLeast(0)&#10;        val progress = (remaining.toFloat() / totalDuration) * 360f&#10;&#10;        // Draw progress arc&#10;        rectF.set(&#10;            centerX - radius + 5,&#10;            centerY - radius + 5,&#10;            centerX + radius - 5,&#10;            centerY + radius - 5&#10;        )&#10;&#10;        // Use red paint if paused, green if active&#10;        val paint = if (isPaused) pausedPaint else progressPaint&#10;        canvas.drawArc(rectF, -90f, progress, false, paint)&#10;&#10;        // Draw remaining time text&#10;        val seconds = (remaining / 1000).toInt()&#10;        val text = if (isPaused) &quot;â¸ ${seconds}s&quot; else &quot;${seconds}s&quot;&#10;        canvas.drawText(text, centerX, centerY + 8, textPaint)&#10;&#10;        // Reset timer when it reaches 0 (only if not paused)&#10;        if (remaining &lt;= 0 &amp;&amp; !isPaused) {&#10;            startTime = System.currentTimeMillis()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Invisible tiny overlay to detect user touches via FLAG_WATCH_OUTSIDE_TOUCH&#10; */&#10;class TouchDetectorView(&#10;    context: Context,&#10;    private val onTouch: () -&gt; Unit&#10;) : View(context) {&#10;&#10;    override fun onTouchEvent(event: MotionEvent?): Boolean {&#10;        // This will be called for outside touches due to FLAG_WATCH_OUTSIDE_TOUCH&#10;        when (event?.action) {&#10;            MotionEvent.ACTION_OUTSIDE -&gt; {&#10;                // User touched outside this tiny 1x1 view (anywhere on screen)&#10;                onTouch()&#10;            }&#10;        }&#10;        return false // Don't consume the touch event - let it pass through&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>